username,userslug,contest_rank,question_id,language,code,submission_id
bpnew,bpnew,1,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T):
            total = 0
            for wt in workerTimes:
                S = (2 * T) // wt
                D = 1 + 4 * S
                if D < 0:
                    xi = 0
                else:
                    sqrt_D = int(D**0.5)
                    xi = (-1 + sqrt_D) // 2
                    while (xi + 1) * xi > S:
                        xi -= 1
                    while (xi + 1) * xi <= S:
                        xi += 1
                    xi -=1
                    xi = max(xi, 0)
                total += xi
            return total >= mountainHeight

        left, right = 0, 1 << 60
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left        ",1397971657
bpnew,bpnew,1,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = sum(1 for word in message if word in banned_set)
        return count >= 2        ",1397960528
bpnew,bpnew,1,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        N = len(word1)
        need = [0]*26
        for c in word2:
            need[ord(c)-ord('a')] +=1
        have = [0]*26
        letters_needed = [i for i in range(26) if need[i]>0]
        left = 0
        total = 0
        for right in range(N):
            c = ord(word1[right])-ord('a')
            have[c] +=1
            while all(have[i]>=need[i] for i in letters_needed):
                have[ord(word1[left])-ord('a')] -=1
                left +=1
            total += left
        return total        ",1397967513
bpnew,bpnew,1,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        counts_word2 = defaultdict(int)
        required_letters = set(word2)
        for c in word2:
            counts_word2[c] += 1

        N = len(word1)
        counts = defaultdict(int)
        total_substrings = 0
        left = 0
        right = 0

        while left < N:
            while right < N and any(counts[char] < counts_word2[char] for char in counts_word2):
                counts[word1[right]] +=1
                right +=1
            if any(counts[char] < counts_word2[char] for char in counts_word2):
                break
            total_substrings += N - right +1
            counts[word1[left]] -=1
            left +=1

        return total_substrings        ",1397970226
Konsept,konssept,2,3496,rust,"impl Solution {
    pub fn min_number_of_seconds(mountain_height: i32, worker_times: Vec<i32>) -> i64 {
        let mut low: i64 = 0;
        let mut high: i64 = 1e18 as i64;
        while low < high {
            let mid = low + (high - low) / 2;
            if Self::can_complete(mid, mountain_height, &worker_times) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        low
    }

    fn can_complete(time_limit: i64, mountain_height: i32, worker_times: &Vec<i32>) -> bool {
        let mut total_height_reduced: i64 = 0;
        for &t in worker_times {
            if t == 0 { continue; }
            let D = 1.0 + 8.0 * time_limit as f64 / t as f64;
            if D < 0.0 { continue; }
            let x = ((-1.0 + D.sqrt()) / 2.0) as i64;
            total_height_reduced += x;
            if total_height_reduced >= mountain_height as i64 {
                return true;
            }
        }
        total_height_reduced >= mountain_height as i64
    }
}",1397965114
Konsept,konssept,2,3541,rust,"use std::collections::HashSet;

impl Solution {
    pub fn report_spam(message: Vec<String>, banned_words: Vec<String>) -> bool {
        let banned_set: HashSet<String> = banned_words.into_iter().collect();
        
        let mut count = 0;
        for word in message {
            if banned_set.contains(&word) {
                count += 1;
                if count >= 2 {
                    return true;
                }
            }
        }
        
        false
    }
}",1397960425
Konsept,konssept,2,3572,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397968792
Konsept,konssept,2,3573,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397971736
Yawn_Sean,Yawn_Sean,3,3496,python3,"class Solution:
    def minNumberOfSeconds(self, h: int, ts: List[int]) -> int:
        l, r = 1, 10 ** 18
        while l <= r:
            m = (l + r) // 2
            x = 0
            for t in ts:
                v = m // t
                # (1 + n) * n / 2 <= v
                # 4 * n ^ 2 + 4 * n + 1 <= 8 v + 1
                x += (math.isqrt(8 * v + 1) - 1) // 2
            if x >= h: r = m - 1
            else: l = m + 1
        return l",1397981466
Yawn_Sean,Yawn_Sean,3,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        vis = set(bannedWords)
        return len([x for x in message if x in vis]) >= 2",1397981838
Yawn_Sean,Yawn_Sean,3,3572,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397981180
Yawn_Sean,Yawn_Sean,3,3573,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397980928
Sid123xyz,Sid123xyz,4,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def is_possible(time):
            total = 0
            for t in workerTimes:
                # We need to solve t * x * (x +1) /2 <= time
                # Which simplifies to x^2 +x - (2*time)/t <=0
                # Solve for x: x = floor( (-1 + sqrt(1 + 8*time/t)) / 2 )
                # To avoid floating point operations, use integer math
                if t == 0:
                    continue
                discriminant = 1 + (8 * time) // t
                if discriminant < 0:
                    continue
                sqrt_d = int(discriminant**0.5)
                x = (sqrt_d -1) // 2
                total += x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * (mountainHeight * (mountainHeight +1)) //2

        while left < right:
            mid = (left + right) //2
            if is_possible(mid):
                right = mid
            else:
                left = mid +1
        return left",1397970239
Sid123xyz,Sid123xyz,4,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        banned_count = 0

    
        for word in message:
            if word in banned_set:
                banned_count += 1
                # If two banned words are found, return True
                if banned_count >= 2:
                    return True

        # If fewer than two banned words are found, return False
        return False
 ",1397961384
Sid123xyz,Sid123xyz,4,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required_counts = defaultdict(int)
        for char in word2:
            required_counts[char] += 1
        required_unique = len(required_counts)

        left = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

        for right in range(n):
            character = word1[right]
            window_counts[character] += 1


            if character in required_counts and window_counts[character] == required_counts[character]:
                formed += 1

            while formed == required_unique:
                result += n - right

 
                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required_counts and window_counts[left_char] < required_counts[left_char]:
                    formed -= 1
                left += 1


        return result
",1397982052
Sid123xyz,Sid123xyz,4,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required = defaultdict(int)
        for char in word2:
            required[char] += 1
        required_unique = len(required)

        left = 0
        right = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

   
        while right < n:
            character = word1[right]
            window_counts[character] += 1

        
            if character in required and window_counts[character] == required[character]:
                formed += 1

        
            while left <= right and formed == required_unique:

                result += n - right  

                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required and window_counts[left_char] < required[left_char]:
                    formed -= 1
                left += 1

            right += 1

        return result
",1397975847
Rahul Shah,rsha256,6,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def helper(m):
            total = 0
            for wt in workerTimes:
                left_x = 0
                right_x = 2 * (10 ** 12)
                while left_x < right_x:
                    mid = (left_x + right_x + 1) // 2
                    cost = wt * mid * (mid + 1) // 2
                    if cost <= m:
                        left_x = mid
                    else:
                        right_x = mid - 1
                total += left_x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight +1) //2
        while left < right:
            mid = (left + right) // 2
            if helper(mid):
                right = mid
            else:
                left = mid + 1
        return left
",1397964841
Rahul Shah,rsha256,6,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        s = set(bannedWords)
        res = 0
        for w in message:
            if w in s:
                res += 1
                if res >= 2: return True
        return False
",1397971576
Rahul Shah,rsha256,6,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397983690
Rahul Shah,rsha256,6,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397982875
Capy,HapCapy,7,3496,python3,"from typing import List
import math

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def max_reducible_height(t):
            total = 0
            for wt in workerTimes:
                discriminant = 1 + (8 * t) // wt
                if discriminant < 0:
                    continue
                x = (math.sqrt(discriminant) - 1) / 2
                total += int(x)
                if total >= mountainHeight:
                    return total
            return total

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        while left < right:
            mid = (left + right) // 2
            if max_reducible_height(mid) >= mountainHeight:
                right = mid
            else:
                left = mid + 1
        return left
",1397974006
Capy,HapCapy,7,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned = set(bannedWords)
        return sum(word in banned for word in message) >= 2
",1397959223
Capy,HapCapy,7,3572,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397985440
Capy,HapCapy,7,3573,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397986255
Wangwang Yang,Jigcecile,8,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long H = mountainHeight;
        vector<long long> wTimes(workerTimes.begin(), workerTimes.end());
        int n = wTimes.size();
        long long Left = 0, Right = 1e16;

        auto getMaxX = [&](long long C) -> long long {
            long long Left = 0, Right = H;
            while (Left <= Right) {
                long long Mid = (Left + Right) / 2;
                long long val = Mid * Mid + Mid;
                if (val <= C) {
                    Left = Mid + 1;
                } else {
                    Right = Mid - 1;
                }
            }
            return Right;
        };

        while (Left < Right) {
            long long Mid = (Left + Right) / 2;
            long long total_x = 0;
            for (int i = 0; i < n; ++i) {
                long long w = wTimes[i];
                long long C = (2 * Mid) / w;
                long long x = getMaxX(C);
                total_x += x;
            }
            if (total_x >= H) {
                Right = Mid;
            } else {
                Left = Mid + 1;
            }
        }
        return Left;
    }
};",1397964893
Wangwang Yang,Jigcecile,8,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> bannedSet(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (bannedSet.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397959008
Wangwang Yang,Jigcecile,8,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> need(26, 0);
        for (char c : word2) {
            need[c - 'a']++;
        }

        vector<int> window(26, 0);
        int required = 0;
        for (int count : need) {
            if (count > 0)
                required++;
        }
        int formed = 0;

        int left = 0;
        long long totalValidSubstrings = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            window[c - 'a']++;
            if (need[c - 'a'] > 0 && window[c - 'a'] == need[c - 'a']) {
                formed++;
            }

            while (left <= right && formed == required) {
                totalValidSubstrings += N - right;

                char lc = word1[left];
                if (need[lc - 'a'] > 0 && window[lc - 'a'] == need[lc - 'a']) {
                    formed--;
                }
                window[lc - 'a']--;
                left++;
            }
        }
        return totalValidSubstrings;
    }
};",1397987330
Wangwang Yang,Jigcecile,8,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> requiredCounts(26, 0);
        for (char c : word2) {
            requiredCounts[c - 'a']++;
        }

        vector<int> windowCounts(26, 0);
        int left = 0;
        long long totalValidSubstrings = 0;
        int requiredChars = 0;

        for (int count : requiredCounts) {
            if (count > 0)
                requiredChars++;
        }

        int formedChars = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            windowCounts[c - 'a']++;

            if (windowCounts[c - 'a'] == requiredCounts[c - 'a']) {
                if (requiredCounts[c - 'a'] > 0) {
                    formedChars++;
                }
            }

            while (formedChars == requiredChars) {
                totalValidSubstrings += N - right;

                char leftChar = word1[left];
                if (windowCounts[leftChar - 'a'] ==
                    requiredCounts[leftChar - 'a']) {
                    if (requiredCounts[leftChar - 'a'] > 0) {
                        formedChars--;
                    }
                }
                windowCounts[leftChar - 'a']--;
                left++;
            }
        }

        return totalValidSubstrings;
    }
};",1397980390
jonathanirvings,jonathanirvings,9,3496,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

vector<pair<LL,int>> triangle;
vector<int> dat;
int h;

bool bisa(LL x)
{
  int total = 0;
  for (int y : dat)
  {
    LL t = x / y;
    vector<pair<LL,int>>::iterator it = upper_bound(ALL(triangle),mp(t,INF));
    --it;
    total += it->se;
    if (total >= h) return true;
  }
  return false;
}

class Solution {
public:
  long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
    if (SIZE(triangle) == 0)
    {
      FORN(i,0,100000)
      {
        triangle.pb(mp((LL)i * (i + 1) / 2, i));
      }
    }
    dat = workerTimes;
    h = mountainHeight;
    LL risan = INFF;
    LL L = 1;
    LL R = INFF;
    while (L <= R)
    {
      LL M = (L + R) >> 1;
      if (bisa(M))
      {
        risan = M;
        R = M - 1;
      } else L = M + 1;
    }
    return risan;
  }
};",1397975279
jonathanirvings,jonathanirvings,9,3541,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

class Solution {
public:
  bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
    set<string> banned(ALL(bannedWords));
    int ada = 0;
    for (string s : message)
    {
      if (banned.count(s)) ++ada;
    }   
    return ada >= 2;
  }
};",1397958787
jonathanirvings,jonathanirvings,9,3572,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987753
jonathanirvings,jonathanirvings,9,3573,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987955
lilPeep,stupidRR,11,3496,cpp,"class Solution {
    long long cnt(long long x)
    {
        long long low=0ll;
        long long high=1e9;
        long long ans=low;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            if((mid*mid+mid)/2ll <= x)
            {
                ans=mid;
                low=mid+1;
            }
            else
                high=mid-1;
        }
        return ans;
    }
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long x=mountainHeight;
        x=(x*x+x)/2ll;
        long long maxTime=*std::min_element(workerTimes.begin(),workerTimes.end());
        maxTime=maxTime*x;
        
        long long low=1;
        long long high=maxTime;
        long long ans=high;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            
            long long red=0ll;
            for(auto time : workerTimes)
                red=red+cnt(mid/time);
            
            if(red>=mountainHeight)
            {
                ans=mid;
                high=mid-1;
            }
            else
                low=mid+1;
        }
        return ans;
    }
};",1397976989
lilPeep,stupidRR,11,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        map<string,int> notAllowed;
        for(auto word : bannedWords)
            notAllowed[word]=1;
        
        int cnt=0;
        for(auto word : message)
            cnt=cnt+notAllowed[word];
        return (cnt>=2);
    }
};",1397960042
lilPeep,stupidRR,11,3572,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397988459
lilPeep,stupidRR,11,3573,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397987933
Ethan,ethanrao,12,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int h, std::vector<int>& t) {
        long long l = 1, r = 1e18; 
        while (l < r) {
            long long mid = l + (r - l) / 2; 
            long long tt = 0;
            for (int time : t) {
                tt += 1ll* (sqrt(1 + 1ll * 8 * mid / time) - 1) / 2;
                if (tt >= h) break;
            }
            if (tt >= h) r = mid;
            else l = mid + 1; 
        }

        return l; 
    }
};
",1397988704
Ethan,ethanrao,12,3541,cpp,"class Solution {
public:
    bool reportSpam(std::vector<std::string>& message, std::vector<std::string>& a) {

        std::unordered_set<std::string> st(a.begin(), a.end());
        int ct = 0;
        
        for (const auto& x : message) 
            if (st.find(x) != st.end()) 
                ct++;
   
        return ct >= 2;
    }
};
",1397982927
Ethan,ethanrao,12,3572,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397980911
Ethan,ethanrao,12,3573,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397982049
pingchungchang,pingchungchang,14,3496,cpp,"class Solution {
public:
#define ll long long
    ll f(ll dt,ll lim){
        lim /= dt;
        ll l = 0,r = 1e9;
        while(l != r){
            ll mid = (l+r+1)>>1;
            if(mid*(mid+1)/2<=lim)l = mid;
            else r = mid-1;
        }
        return l;
    }
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        ll l = 0,r = 1e18;
        while(l != r){
            ll mid = (l+r)>>1;
            ll s = 0;
            for(auto &i:workerTimes){
                s += f(i,mid);
            }
            if(s>=mountainHeight)r = mid;
            else l = mid+1;
        }
        return l;
    }
};",1397972226
pingchungchang,pingchungchang,14,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_map<string, int> mp;
        for (auto it: bannedWords) mp[it] = 1;
        int n = 0;
        for (auto it:message){
            if (mp.count(it) != 0) n++; 
        }
        if (n >= 2) return true;
        else return false;
    }
};",1397973583
pingchungchang,pingchungchang,14,3572,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397987874
pingchungchang,pingchungchang,14,3573,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397989212
Shivam,itshivam,15,3496,golang,"package main

import (
	
	""sort""
)

func minNumberOfSeconds(mountainHeight int, workerTimes []int) int64 {
	left := int64(min(workerTimes))                         
	right := int64(mountainHeight*(mountainHeight+1)) / 2 * left 

	for left < right {
		mid := left + (right-left)/2
		if canReduceAll(mountainHeight, workerTimes, mid) {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func canReduceAll(mountainHeight int, workerTimes []int, maxTime int64) bool {
	totalUnits := int64(0)

	for _, time := range workerTimes {
		low, high := int64(1), int64(mountainHeight)

		for low <= high {
			mid := low + (high-low)/2
			if canWork(time, mid) <= maxTime {
				low = mid + 1
			} else {
				high = mid - 1
			}
		}

		totalUnits += high
		if totalUnits >= int64(mountainHeight) {
			return true
		}
	}

	return totalUnits >= int64(mountainHeight)
}

func canWork(time int, x int64) int64 {
	return int64(time) * x * (x + 1) / 2
}

func min(arr []int) int {
	sort.Ints(arr)
	return arr[0]
}


",1397989329
Shivam,itshivam,15,3541,golang,"package main

import (
	""fmt""
)

func reportSpam(message []string, bannedWords []string) bool {
	bannedSet := make(map[string]struct{})
	for _, word := range bannedWords {
		bannedSet[word] = struct{}{}
	}

	count := 0
	for _, word := range message {
		if _, exists := bannedSet[word]; exists {
			count++
			if count == 2 {
				return true 
			}
		}
	}

	return false 
}


",1397985195
Shivam,itshivam,15,3572,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397983051
Shivam,itshivam,15,3573,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397982401
Abhishek kumar,abhishek-exists,17,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def can_reduce_in_time(time: int) -> bool:
            total_reduction = sum(
                int((((8 * time / worker_time) + 1) ** 0.5 - 1) / 2)
                for worker_time in workerTimes
            )
            return total_reduction >= mountainHeight

        left = 1
        right = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        
        # Apply bin search
        while left < right:
            mid = (left + right) // 2
            if can_reduce_in_time(mid):
                right = mid
            else:
                left = mid + 1

        return left",1397976783
Abhishek kumar,abhishek-exists,17,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        return sum(1 for word in message if word in banned_set) >= 2",1397960041
Abhishek kumar,abhishek-exists,17,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        required = len(target)
        formed = 0

        for right in range(len(word1)):
            # Expand the window
            current[word1[right]] += 1
            if word1[right] in target and current[word1[right]] == target[word1[right]]:
                formed += 1

            # Contract the window if all required characters are formed
            while formed == required:
                count += len(word1) - right
                
                # Remove the leftmost character
                if word1[left] in target and current[word1[left]] == target[word1[left]]:
                    formed -= 1
                current[word1[left]] -= 1
                left += 1

        return count",1397989816
Abhishek kumar,abhishek-exists,17,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        
        # Using sliding window
        for right in range(len(word1)):
            current[word1[right]] += 1
            
            while all(current[char] >= target[char] for char in target):
                count += len(word1) - right
                current[word1[left]] -= 1
                left += 1
        
        return count",1397984924
Ryan,ryanwong0127,18,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def get_max_x(m):
            if m < 0:
                return 0
            low_x, high_x = 0, m
            while low_x <= high_x:
                mid_x = (low_x + high_x) // 2
                if mid_x * (mid_x + 1) <= m:
                    low_x = mid_x + 1
                else:
                    high_x = mid_x - 1
            return high_x

        max_worker_time = max(workerTimes)
        H = mountainHeight
        t_upper = max_worker_time * H * (H + 1) // 2
        low, high = 0, t_upper

        while low < high:
            mid = (low + high) // 2
            s = 2 * mid
            total_x = 0
            for c in workerTimes:
                m = s // c
                x = get_max_x(m)
                total_x += x
            if total_x >= H:
                high = mid
            else:
                low = mid + 1
        return low",1397979559
Ryan,ryanwong0127,18,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        match_count = 0

        for word in message:
            if word in banned_set:
                match_count += 1
                if match_count >= 2:
                    return True

        return False",1397960562
Ryan,ryanwong0127,18,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397989585
Ryan,ryanwong0127,18,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397990058
Ian Wong,ianwong1999,19,3496,cpp,"class Solution {
public:
    using ull = long long;
    using P = pair<ull, int>;
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<P, vector<P>, greater<P>> pq;
        
        int n = workerTimes.size();
        
        vector<long long> vec(n);
        vector<long long> cnt(n);
        
        for (int i = 0; i < n; i++) {
            vec[i] = workerTimes[i];
            cnt[i] = 1;
            pq.emplace(workerTimes[i], i);
        }
        
        long long res = 0;
        cout << endl;
        while (mountainHeight > 0) {
            auto [cost, id] = pq.top(); pq.pop();
            res = max(res, cost);
            cnt[id]++;
            vec[id] += cnt[id] * workerTimes[id];
            pq.emplace(vec[id], id);
            mountainHeight--;
        }
        
        return res;
    }
};",1397976160
Ian Wong,ianwong1999,19,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        set<string> s;
        for (const auto& ss : bannedWords) s.insert(ss);
        
        
        int cnt = 0;
        for (const auto& ss : message) cnt += s.count(ss);
        
        return cnt >= 2;
    }
};",1397959019
Ian Wong,ianwong1999,19,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397990107
Ian Wong,ianwong1999,19,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397989569
a11,TravellingSalesman23,21,3496,cpp,"class Solution {
public:
    long long mountainHeight;
    vector<int> workerTimes;

    long long integer_sqrt(long long n) {
        if (n == 0 || n == 1)
            return n;
        long long left = 1, right = n;
        while (left <= right) {
            long long mid = left + (right - left) / 2;
            if (mid <= n / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    bool f(long long t) {
        long long sum_x = 0;
        for (int i = 0; i < workerTimes.size(); ++i) {
            long long A = workerTimes[i];
            if (A == 0) continue; 
            long long t_div_A = t / A;
            long long D = 1 + 8 * t_div_A;
            long long D_sqrt = integer_sqrt(D);
            long long x = (D_sqrt - 1) / 2;
            sum_x += x;
            if (sum_x >= mountainHeight)
                return true;
        }
        return sum_x >= mountainHeight;
    }

    long long minNumberOfSeconds(int mountainHeightParam, vector<int>& workerTimesParam) {
        mountainHeight = mountainHeightParam;
        workerTimes = workerTimesParam;

        long long low = 0, high = 1e18;
        while (low < high) {
            long long mid = (low + high) / 2;
            if (f(mid))
                high = mid;
            else
                low = mid + 1;
        }
        return low;
    }
};",1397983129
a11,TravellingSalesman23,21,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> banned_set(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (banned_set.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397987190
a11,TravellingSalesman23,21,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        vector<int> need(26, 0), have(26, 0);
        int required_chars = 0;
        int matched_chars = 0;  

        for (char c : word2) {
            if (need[c - 'a'] == 0) {
                required_chars++;
            }
            need[c - 'a']++;
        }

        int left = 0;
        long long total = 0;
        int N = word1.size();

        for (int right = 0; right < N; ++right) {
            int c = word1[right] - 'a';
            have[c]++;
            if (have[c] == need[c]) {
                matched_chars++;
            }

            while (left <= right && have[word1[left] - 'a'] > need[word1[left] - 'a']) {
                have[word1[left] - 'a']--;
                left++;
            }

            if (matched_chars == required_chars) {
                total += left + 1;
            }
        }

        return total;
    }
};",1397991250
a11,TravellingSalesman23,21,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int required_counts[26] = {0};
        for (char c : word2) {
            required_counts[c - 'a']++;
        }

        vector<int> letters;
        for (int c = 0; c < 26; ++c) {
            if (required_counts[c] > 0) {
                letters.push_back(c);
            }
        }
        vector<int> counts[26]; 
        vector<vector<int>> positions_c[26]; 

        for (int c : letters) {
            counts[c] = vector<int>(n + 1, 0);
            for (int pos = 1; pos <= n; ++pos) {
                counts[c][pos] = counts[c][pos - 1] + (word1[pos - 1] - 'a' == c ? 1 : 0);
            }

            int max_count = counts[c][n];
            positions_c[c] = vector<vector<int>>(max_count + 1);
            for (int pos = 0; pos <= n; ++pos) {
                int k = counts[c][pos];
                positions_c[c][k].push_back(pos);
            }
        }

        long long total = 0;

        for (int i = 1; i <= n; ++i) {
            int pos_max = -1;
            bool valid = true;

            for (int c : letters) {
                int counts_c_i_minus_1 = counts[c][i - 1];
                int K = counts_c_i_minus_1 + required_counts[c];

                if (K > counts[c][n]) {
                    valid = false;
                    break;
                }

                auto& positions = positions_c[c][K];
                auto it = lower_bound(positions.begin(), positions.end(), i);
                if (it == positions.end()) {
                    valid = false;
                    break;
                }
                int pos_c = *it;
                pos_max = max(pos_max, pos_c);
            }

            if (valid && pos_max <= n) {
                total += n - pos_max + 1;
            }
        }

        return total;
    }
};",1397979090
Ma Lin,Ma_Lin,22,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int H, vector<int>& a) {
        long long st = 1, ed = 10000000000000000LL, mid, res = 0, now, i, j, x;
        while (st <= ed){
            mid = (st + ed) / 2;
            now = H;
            for (auto q : a){
                if (q > mid) continue;
                x = (sqrt(1 + 8 * mid / q) - 1) / 2;
                now -= x;
                if (now <= 0) break;
            }
            
            if (now <= 0){
                res = mid;
                ed = mid - 1;
            }
            else st = mid + 1;
        }
        
        return res;
    }
};",1397981435
Ma Lin,Ma_Lin,22,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& a, vector<string>& b) {
        int ge = 0;
        unordered_set<string> S;
        for (auto w : b) S.insert(w);
        for (auto w : a)
            if (S.count(w)) ++ge;
        return ge >= 2;
    }
};",1397958958
Ma Lin,Ma_Lin,22,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991661
Ma Lin,Ma_Lin,22,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991001
Shacola,shacola,23,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T: int) -> bool:
            cnt = 0
            for time in workerTimes:
                if time == 0:
                    continue
                discriminant = 1 + 8 * T // time
                if discriminant < 0:
                    continue
                sqrt_discriminant = math.isqrt(discriminant)
                x = (sqrt_discriminant - 1) // 2
                if x > 0:
                    cnt += x
                if cnt >= mountainHeight:
                    return True
            return cnt >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * \
            (mountainHeight + 1) // 2

        ans = right
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        return ans",1397973858
Shacola,shacola,23,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        st = set(bannedWords)
        cnt = 0
        for word in message:
            if word in st:
                cnt += 1
                if cnt >= 2:
                    return True
        return False",1397965421
Shacola,shacola,23,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397992187
Shacola,shacola,23,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397984188
penguinhacker,penguinhacker,24,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
        for (int i : workerTimes)
            pq.push({i, i, 2});
        long long ans=0;
        while(mountainHeight--) {
            auto x=pq.top();
            pq.pop();
            ans=x[0];
            pq.push({x[0]+x[2]*x[1], x[1], x[2]+1});
        }
        return ans;
    }
};",1397973249
penguinhacker,penguinhacker,24,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& banned) {
        int cnt=0;
        set<string> s(banned.begin(), banned.end());
        for (string ss : message)
            cnt += s.count(ss);
        return cnt>=2;
    }
};",1397959294
penguinhacker,penguinhacker,24,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397981676
penguinhacker,penguinhacker,24,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397982248
Sambhav Jain,Sambhav-Jain,25,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) 
    {
        long long ans = 0;
        auto helper=[=](long long sum) -> int
        {
            long long ans = 0;
            for (long long start = 0, end = 1e9, mid; start <= end;)
            {
                mid = (start + end) / 2;
                if (mid * (mid + 1) / 2 <= sum)
                {
                    ans= mid;
                    start = mid + 1;
                }
                else
                {
                    end = mid - 1;
                }
            }
            return ans;
        };
        for (long long start = 0, end = 1e18, mid; start <= end;)
        {
            mid = (start + end) / 2;
            long long sum = 0;
            for (auto &i : workerTimes)
            {
                sum += helper(mid / i);
            }
            if (sum >= mountainHeight)
            {
                ans = mid;
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return ans;
    }
};",1397985093
Sambhav Jain,Sambhav-Jain,25,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) 
    {
        map<string, bool> amap;
        map<string, int> freq;
        for (auto &i : bannedWords)
        {
            amap[i] = true;
        }
        int cnt = 0;
        for (auto &i : message)
        {
           cnt += amap[i];
        }
        return (cnt >= 2);
        return false;
    }
};",1397962939
Sambhav Jain,Sambhav-Jain,25,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992682
Sambhav Jain,Sambhav-Jain,25,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992282
Yawn_Sean,Yawn_Sean,1,3518,python3,"class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        dp = [-inf] * 5
        dp[0] = 0
        for x in b:
            for i in range(4, 0, -1):
                dp[i] = max(dp[i], dp[i-1] + a[i-1] * x)
        return dp[-1]",1390502796
Yawn_Sean,Yawn_Sean,1,3557,python3,"pw = random.randint(100, 200)
mod = random.getrandbits(40)

pws = [1]
for _ in range(10 ** 5):
    pws.append(pws[-1] * pw % mod)

class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        n = len(target)
        
        vis = set()
        for w in words:
            x = 0
            for c in w:
                x = (x * pw + ord(c)) % mod
                vis.add(x)
        
        acc = [0]
        for c in target:
            acc.append((acc[-1] * pw + ord(c)) % mod)
        
        l = r = 0
        cnt = 0
        while r < n:
            nr = r
            for i in range(l, r + 1):
                left, right = i, n - 1
                while left <= right:
                    mid = (left + right) // 2
                    if (acc[mid+1] - acc[i] * pws[mid+1-i] % mod) % mod in vis:
                        left = mid + 1
                    else:
                        right = mid - 1
                if right + 1 > nr:
                    nr = right + 1
                mid = right
            if nr == r: return -1
            l, r = r + 1, nr
            cnt += 1
        return cnt
        ",1390503388
Yawn_Sean,Yawn_Sean,1,3559,python3,"pw = random.randint(100, 200)
mod = random.getrandbits(40)

pws = [1]
for _ in range(10 ** 5):
    pws.append(pws[-1] * pw % mod)

class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        n = len(target)
        
        vis = set()
        for w in words:
            x = 0
            for c in w:
                x = (x * pw + ord(c)) % mod
                vis.add(x)
        
        acc = [0]
        for c in target:
            acc.append((acc[-1] * pw + ord(c)) % mod)
        
        l = r = 0
        cnt = 0
        while r < n:
            nr = r
            for i in range(l, r + 1):
                left, right = i, n - 1
                while left <= right:
                    mid = (left + right) // 2
                    if (acc[mid+1] - acc[i] * pws[mid+1-i] % mod) % mod in vis:
                        left = mid + 1
                    else:
                        right = mid - 1
                if right + 1 > nr:
                    nr = right + 1
                mid = right
            if nr == r: return -1
            l, r = r + 1, nr
            cnt += 1
        return cnt
        ",1390502710
Yawn_Sean,Yawn_Sean,1,3581,python3,"class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        cnt = Counter(nums)
        return [x for x in cnt if cnt[x] == 2]",1390503049
Kai Wen Yang,_kevinyang,4,3518,cpp,"class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        vector<vector<long long>>dp(5,vector<long long>(n+1,-1e18));
        for(int j = 0; j<=n; j++){
            dp[0][j] = 0;
        }
        for(int t = 1; t<5; t++){
            for(int i = 1; i<=n; i++){
                dp[t][i] = max(dp[t][i-1],dp[t-1][i-1] + 1ll*a[t-1]*b[i-1]);
            }
        }
        return dp[4][n];
    }
};",1390504936
Kai Wen Yang,_kevinyang,4,3557,cpp,"class Solution {
public:
    struct PolyHash{
	/*
	WARNING: make sure the values in the array or string are in the range [0,5e8]
	*/
	vector<long long>powers;
	vector<long long>powers2;
	vector<long long>hashes;
	vector<long long>hashes2;
	long long seed = 500002961;
	long long seed2 = 500003263;
	const long long mod = (long long)1e9+7;
	const long long mod2 = 998244353;
	vector<long long>arr;
	void init(long long n){
		powers.resize(n+5); powers[0] = 1;
		powers2.resize(n+5); powers2[0] = 1;
		hashes.resize(n+5);
		hashes2.resize(n+5);
		for(long long i = 1; i<=n; i++){
			powers[i] = powers[i-1]*seed; powers[i]%=mod;
			powers2[i] = powers2[i-1]*seed2; powers2[i]%=mod2;
		}
		for(long long i = 1; i<=n; i++){
			hashes[i] = hashes[i-1]*seed+arr[i]; hashes[i]%=mod;
			hashes2[i] = hashes2[i-1]*seed2+arr[i]; hashes2[i]%=mod2;
		}
	}
	void init(long long n, string s){//string is 0 indexed
		arr.resize(n+5);
		for(long long i = 1; i<=n; i++){
			arr[i] = s[i-1];
		}
		init(n);
	}
	void init(long long n, vector<long long>a){//a is 1 indexed
		arr.resize(n+5);
		for(long long i = 1; i<=n; i++){
			arr[i] = a[i];
		}
		init(n);
	}
	pair<long long,long long> subhash(long long l, long long r){//inclusive
		long long hsh = hashes[r]-hashes[l-1]*powers[r-l+1]%mod; hsh+=mod; hsh%=mod;
		long long hsh2 = hashes2[r]-hashes2[l-1]*powers2[r-l+1]%mod2; hsh2+=mod2; hsh2%=mod2;
		return {hsh,hsh2};
	}
};
    struct SegTree{
	int size;
	vector<int>arr;
	void init(int n){
		size = 1;
		while(size<n)size*=2;
		arr.assign(2*size,0LL);
	}
	void set(int i, int v, int x, int lx, int rx){
		if(rx-lx==1){
			arr[x] = v;
			return;
		}
		int m = (lx+rx)/2;
		if(i<m){
			set(i,v,2*x+1,lx,m);
		}
		else{
			set(i,v,2*x+2,m,rx);
		}
		arr[x] = min(arr[2*x+1],arr[2*x+2]);
	}
	void set(int i,int v){
		set(i,v,0,0,size);
	}
	int query(int l,int r, int x, int lx, int rx){
		if(lx>=r||l>=rx)return (int)1e9;
		if(lx>=l&&rx<=r)return arr[x];
		int m = (lx+rx)/2;
		int s1 = query(l,r,2*x+1,lx,m);
		int s2 = query(l,r,2*x+2,m,rx);
		return min(s1,s2);
	}
	int query(int l, int r){
		return query(l,r,0,0,size);
	}
};
    
    int minValidStrings(vector<string>& words, string target) {
        int n = target.size();
        PolyHash hsh;
        hsh.init(n,target);
        target = "" "" + target;
        SegTree segtree;
        segtree.init(n+5);
        for(int i = 1; i<=n; i++){
            segtree.set(i,1e9);
        }
        vector<pair<long long, long long>>hm;
        for(string s : words){
            PolyHash hs;
            int m = s.size();
            hs.init(m,s);
            for(int i = 1; i<=m; i++){
                hm.push_back(hs.subhash(1,i));
            }
            
        }
        sort(hm.begin(),hm.end());
       
        auto search = [&](pair<long long, long long>p) -> bool{
            auto it = lower_bound(hm.begin(),hm.end(),p);
            if(it != hm.end() && *it == p){
                return true;
            }
            return false;
        };
        for(int i = n; i>=1; i--){
            int low = i-1; int high = n+1;
            while(low + 1 < high){
                int mid = (low+high)/2;
                if(search(hsh.subhash(i,mid))){
                    low = mid;
                }
                else{
                    high = mid;
                }
            }
            if(low >= i){
                int v = segtree.query(i+1,low+2);
                segtree.set(i,v+1);
            }
        }
        int res = segtree.query(1,2);
        if(res > (int)1e7){
            return -1;
        }
        return res;
    }
};",1390504185
Kai Wen Yang,_kevinyang,4,3559,cpp,"class Solution {
public:
    struct PolyHash{
	/*
	WARNING: make sure the values in the array or string are in the range [0,5e8]
	*/
	vector<long long>powers;
	vector<long long>powers2;
	vector<long long>hashes;
	vector<long long>hashes2;
	long long seed = 500002961;
	long long seed2 = 500003263;
	const long long mod = (long long)1e9+7;
	const long long mod2 = 998244353;
	vector<long long>arr;
	void init(long long n){
		powers.resize(n+5); powers[0] = 1;
		powers2.resize(n+5); powers2[0] = 1;
		hashes.resize(n+5);
		hashes2.resize(n+5);
		for(long long i = 1; i<=n; i++){
			powers[i] = powers[i-1]*seed; powers[i]%=mod;
			powers2[i] = powers2[i-1]*seed2; powers2[i]%=mod2;
		}
		for(long long i = 1; i<=n; i++){
			hashes[i] = hashes[i-1]*seed+arr[i]; hashes[i]%=mod;
			hashes2[i] = hashes2[i-1]*seed2+arr[i]; hashes2[i]%=mod2;
		}
	}
	void init(long long n, string s){//string is 0 indexed
		arr.resize(n+5);
		for(long long i = 1; i<=n; i++){
			arr[i] = s[i-1];
		}
		init(n);
	}
	void init(long long n, vector<long long>a){//a is 1 indexed
		arr.resize(n+5);
		for(long long i = 1; i<=n; i++){
			arr[i] = a[i];
		}
		init(n);
	}
	pair<long long,long long> subhash(long long l, long long r){//inclusive
		long long hsh = hashes[r]-hashes[l-1]*powers[r-l+1]%mod; hsh+=mod; hsh%=mod;
		long long hsh2 = hashes2[r]-hashes2[l-1]*powers2[r-l+1]%mod2; hsh2+=mod2; hsh2%=mod2;
		return {hsh,hsh2};
	}
};
    struct SegTree{
	int size;
	vector<int>arr;
	void init(int n){
		size = 1;
		while(size<n)size*=2;
		arr.assign(2*size,0LL);
	}
	void set(int i, int v, int x, int lx, int rx){
		if(rx-lx==1){
			arr[x] = v;
			return;
		}
		int m = (lx+rx)/2;
		if(i<m){
			set(i,v,2*x+1,lx,m);
		}
		else{
			set(i,v,2*x+2,m,rx);
		}
		arr[x] = min(arr[2*x+1],arr[2*x+2]);
	}
	void set(int i,int v){
		set(i,v,0,0,size);
	}
	int query(int l,int r, int x, int lx, int rx){
		if(lx>=r||l>=rx)return (int)1e9;
		if(lx>=l&&rx<=r)return arr[x];
		int m = (lx+rx)/2;
		int s1 = query(l,r,2*x+1,lx,m);
		int s2 = query(l,r,2*x+2,m,rx);
		return min(s1,s2);
	}
	int query(int l, int r){
		return query(l,r,0,0,size);
	}
};
    
    int minValidStrings(vector<string>& words, string target) {
        int n = target.size();
        PolyHash hsh;
        hsh.init(n,target);
        target = "" "" + target;
        SegTree segtree;
        segtree.init(n+5);
        for(int i = 1; i<=n; i++){
            segtree.set(i,1e9);
        }
        vector<pair<long long, long long>>hm;
        for(string s : words){
            PolyHash hs;
            int m = s.size();
            hs.init(m,s);
            for(int i = 1; i<=m; i++){
                hm.push_back(hs.subhash(1,i));
            }
            
        }
        sort(hm.begin(),hm.end());
       
        auto search = [&](pair<long long, long long>p) -> bool{
            auto it = lower_bound(hm.begin(),hm.end(),p);
            if(it != hm.end() && *it == p){
                return true;
            }
            return false;
        };
        for(int i = n; i>=1; i--){
            int low = i-1; int high = n+1;
            while(low + 1 < high){
                int mid = (low+high)/2;
                if(search(hsh.subhash(i,mid))){
                    low = mid;
                }
                else{
                    high = mid;
                }
            }
            if(low >= i){
                int v = segtree.query(i+1,low+2);
                segtree.set(i,v+1);
            }
        }
        int res = segtree.query(1,2);
        if(res > (int)1e7){
            return -1;
        }
        return res;
    }
};",1390504723
Kai Wen Yang,_kevinyang,4,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        vector<int>ans;
        map<int,int>hm;
        for(int nxt: nums){
            if(hm.count(nxt)){
                ans.push_back(nxt);
            }
            hm[nxt] = 1;
        }
        return ans;
    }
};",1390505070
Nicholas,nicholask_17,5,3518,cpp,"class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        vector <long long> dp(5,-1e18);
        dp[0]=0;
        for (int i:b){
            vector <long long> nw=dp;
            for (int j=0; j<4; j++){
                nw[j+1]=max(nw[j+1],dp[j]+1LL*a[j]*i);
            }
            dp=nw;
        }
        return dp.back();
    }
};",1390482657
Nicholas,nicholask_17,5,3557,cpp,"class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n=target.size();
        vector <int> len(n,0);
        for (string i:words){
            string s=i; s+='#'; s+=target;
            int m=s.size();
            vector <int> z(m);
            int l=0,r=0;
            for (int i=1; i<m; i++){
                if (i<r) z[i]=min(r-i,z[i-l]);
                while (i+z[i]<m&&s[z[i]]==s[i+z[i]]) z[i]++;
                if (i+z[i]>r){
                    l=i;
                    r=i+z[i];
                }
            }
            int sz=i.size();
            for (int j=0; j<n; j++) len[j]=max(len[j],z[j+sz+1]); 
        }
        multiset <int> ms;
        target="" ""+target;
        int dp[n+1];
        dp[0]=0;
        for (int i=1; i<=n; i++) dp[i]=1e9;
        vector <int> done[n+1];
        for (int i=1; i<=n; i++){
            for (int j:done[i]) ms.erase(ms.find(j));
            if (len[i-1]){
                ms.insert(dp[i-1]+1);
                if (i+len[i-1]<=n) done[i+len[i-1]].push_back(dp[i-1]+1);
            }
            if (!ms.empty()) dp[i]=*ms.begin();
        }
        if (dp[n]>=1e8) dp[n]=-1;
        return dp[n];
    }
};",1390505650
Nicholas,nicholask_17,5,3559,cpp,"class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n=target.size();
        vector <int> len(n,0);
        for (string i:words){
            string s=i; s+='#'; s+=target;
            int m=s.size();
            vector <int> z(m);
            int l=0,r=0;
            for (int i=1; i<m; i++){
                if (i<r) z[i]=min(r-i,z[i-l]);
                while (i+z[i]<m&&s[z[i]]==s[i+z[i]]) z[i]++;
                if (i+z[i]>r){
                    l=i;
                    r=i+z[i];
                }
            }
            int sz=i.size();
            for (int j=0; j<n; j++) len[j]=max(len[j],z[j+sz+1]); 
        }
        multiset <int> ms;
        target="" ""+target;
        int dp[n+1];
        dp[0]=0;
        for (int i=1; i<=n; i++) dp[i]=1e9;
        vector <int> done[n+1];
        for (int i=1; i<=n; i++){
            for (int j:done[i]) ms.erase(ms.find(j));
            if (len[i-1]){
                ms.insert(dp[i-1]+1);
                if (i+len[i-1]<=n) done[i+len[i-1]].push_back(dp[i-1]+1);
            }
            if (!ms.empty()) dp[i]=*ms.begin();
        }
        if (dp[n]>=1e8) dp[n]=-1;
        return dp[n];
    }
};",1390505879
Nicholas,nicholask_17,5,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        map <int,int> mp;
        for (int i:nums) mp[i]++;
        vector <int> v;
        for (auto i:mp) if (i.second>1) v.push_back(i.first);
        return v;
    }
};",1390477388
Sreesh Maheshwar,sreeshmaheshwar,6,3518,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int n = sz(b);
        const ll INF = (ll)1e18;
        vt<ll>dp(5,-INF);
        dp[0]=0;
        for (auto x : b) {
            auto ndp = dp;
            forn(4){
                if (dp[i] == -INF) continue;
                umax(ndp[i+1],dp[i]+1LL*a[i]*x);
            }
            dp = ndp;
        }
        return dp.back();
    }
};",1390505105
Sreesh Maheshwar,sreeshmaheshwar,6,3557,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

template<typename T, typename T_elem>
int get_link(const T &pattern, const vector<int> &fail, int len, const T_elem &c) {
    while (len > 0 && pattern[len] != c) {
        len = fail[len];
    }
    if (pattern[len] == c) {
        len++;
    }
    return len;
}

template<typename T>
vector<int> compute_failure_function(const T &pattern) {
    // fail[i] = for the prefix [0, i] of `pattern`, the length of the longest proper prefix that is also a suffix.
    int n = int(pattern.size());
    vector<int> fail(n + 1, 0);
    int len = 0;
    for (int i = 1; i < n; i++) {
        len = get_link(pattern, fail, len, pattern[i]);
        fail[i + 1] = len;
    }
    fail.erase(fail.begin());
    return fail;
}

class Solution {
public:
    int minValidStrings(vector<string>& a, string t) {
        int N = sz(a), m = sz(t);
        vt<int> kmp(m);
        forn(N) {
            auto cur = compute_failure_function(a[i] + '#' + t);
            forn(j, m){
                umax(kmp[j],cur[sz(a[i])+1+j]);
            }
        }
        int r = m - 1, ans = 0;
        while (r >= 0) {
            if (kmp[r] == 0) {
                return -1;
            }
            r -= kmp[r];
            ans++;
        }
        return ans;
    }
};",1390495230
Sreesh Maheshwar,sreeshmaheshwar,6,3559,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

template<typename T, typename T_elem>
int get_link(const T &pattern, const vector<int> &fail, int len, const T_elem &c) {
    while (len > 0 && pattern[len] != c) {
        len = fail[len];
    }
    if (pattern[len] == c) {
        len++;
    }
    return len;
}

template<typename T>
vector<int> compute_failure_function(const T &pattern) {
    // fail[i] = for the prefix [0, i] of `pattern`, the length of the longest proper prefix that is also a suffix.
    int n = int(pattern.size());
    vector<int> fail(n + 1, 0);
    int len = 0;
    for (int i = 1; i < n; i++) {
        len = get_link(pattern, fail, len, pattern[i]);
        fail[i + 1] = len;
    }
    fail.erase(fail.begin());
    return fail;
}

class Solution {
public:
    int minValidStrings(vector<string>& a, string t) {
        int N = sz(a), m = sz(t);
        vt<int> kmp(m);
        forn(N) {
            auto cur = compute_failure_function(a[i] + '#' + t);
            forn(j, m){
                umax(kmp[j],cur[sz(a[i])+1+j]);
            }
        }
        int r = m - 1, ans = 0;
        while (r >= 0) {
            if (kmp[r] == 0) {
                return -1;
            }
            r -= kmp[r];
            ans++;
        }
        return ans;
    }
};",1390497050
Sreesh Maheshwar,sreeshmaheshwar,6,3581,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& a) {
        int n = sz(a);
        vt<int>mp(n);
        forn(n){
            mp[a[i]]++;
        }
        vt<int>ret;
        forn(n){
            if(mp[i]==2)ret.pb(i);
        }
        return ret;
    }
};",1390507510
Happy Potato,happypotato1207,8,3518,cpp,"class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        vector<vector<long long>> dp(n + 1);
        for (int i = 0; i <= n; i++) dp[i].resize(5);
        for (int i = 0; i <= 4; i++) dp[0][i] = (i == 0 ? 0 : -1e18);
        for (int i = 1; i <= n; i++) {
            long long x = b[i - 1];
            for (int j = 0; j <= 4; j++) dp[i][j] = dp[i - 1][j];
            for (int j = 1; j <= 4; j++) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + x * a[j - 1]);
        }
        return dp[n][4];
    }
};",1390486435
Happy Potato,happypotato1207,8,3557,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ld long double
#define pii pair<int, int>
#define pll pair<ll int, ll int>
#define ff first
#define ss second
#define pb push_back
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
using namespace std;
class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = target.length();
        vector<vector<int>> ranges(n + 1);
        for (string &str : words) {
            int m = str.length();
            vector<int> kmp(m);
            kmp[0] = 0;
            int ptr = 0;
            for (int i = 1; i < m; i++) {
                while (true) {
                    if (str[i] == str[ptr]) {
                        kmp[i] = ++ptr;
                        break;
                    } else {
                        if (ptr == 0) {
                            kmp[i] = 0; break;
                        }
                        ptr = kmp[ptr - 1];
                    }
                }
            }
            ptr = 0;
            for (int i = 0; i < n; i++) {
                while (ptr > 0 && target[i] != str[ptr]) {
                    ptr = kmp[ptr - 1];
                }
                if (target[i] == str[ptr]) ptr++;
                if (ptr > 0) ranges[i + 1].pb((i + 1) - ptr);
            }
        }
        const int MAX = 1e9;
        vector<int> dp(n + 1, MAX);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int &cur : ranges[i]) {
                dp[i] = min(dp[i], dp[cur] + 1);
            }
        }
        return (dp[n] == MAX ? -1 : dp[n]);
    }
};",1390508239
Happy Potato,happypotato1207,8,3559,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ld long double
#define pii pair<int, int>
#define pll pair<ll int, ll int>
#define ff first
#define ss second
#define pb push_back
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
using namespace std;
class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = target.length();
        vector<vector<int>> ranges(n + 1);
        for (string &str : words) {
            int m = str.length();
            vector<int> kmp(m);
            kmp[0] = 0;
            int ptr = 0;
            for (int i = 1; i < m; i++) {
                while (true) {
                    if (str[i] == str[ptr]) {
                        kmp[i] = ++ptr;
                        break;
                    } else {
                        if (ptr == 0) {
                            kmp[i] = 0; break;
                        }
                        ptr = kmp[ptr - 1];
                    }
                }
            }
            ptr = 0;
            for (int i = 0; i < n; i++) {
                while (ptr > 0 && target[i] != str[ptr]) {
                    ptr = kmp[ptr - 1];
                }
                if (target[i] == str[ptr]) ptr++;
                if (ptr > 0) ranges[i + 1].pb((i + 1) - ptr);
            }
        }
        const int MAX = 1e9;
        vector<int> dp(n + 1, MAX);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int &cur : ranges[i]) {
                dp[i] = min(dp[i], dp[cur] + 1);
            }
        }
        return (dp[n] == MAX ? -1 : dp[n]);
    }
};",1390508489
Happy Potato,happypotato1207,8,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        map<int, int> mp;
        for (int x : nums) mp[x]++;
        vector<int> ans;
        for (pair<int, int> cur : mp) {
            if (cur.second == 2) ans.push_back(cur.first);
        }
        return ans;
    }
};",1390478030
IphoneX,hahahiehie,11,3518,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    //    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    //    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    public long maxScore(int[] a, int[] b) {
        int m = a.length;
        int n = b.length;
        long INF = 1L << 50;
        long[][] dp = new long[m][n];
        ArrayUtils.fill(dp, -INF);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > j) {
                    continue;
                }
                if (j - 1 >= 0) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);
                }
                dp[i][j] = Math.max(dp[i][j], (long) a[i] * b[j] + (i - 1 >= 0 && j - 1 >= 0 ? dp[i - 1][j - 1] : 0));
            }
        }
        return dp[m - 1][n - 1];
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1390496099
IphoneX,hahahiehie,11,3557,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    //    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    //    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static class ACAutomation {
        private static class TrieNode {
            TrieNode[] next = new TrieNode[26];
            // suffix node that is the longest suffix of current node.
            TrieNode suffix = null;
            // source node that contains a word.
            TrieNode src = null;
            String word = null;
            int depth = 0;
        }

        private TrieNode root = new TrieNode();
        private TrieNode curSearchNode = root;

        // DO NOT insert empty word ("""").
        public void insert(String word) {
            TrieNode cur = root;
            for (int i = 0; i < word.length(); i++) {
                int c = word.charAt(i) - 'a';
                if (cur.next[c] == null) {
                    cur.next[c] = new TrieNode();
                }
                cur = cur.next[c];
                cur.depth = i + 1;
            }
            cur.src = cur;
            cur.word = word;
        }

        private TrieNode getSuffixChild(TrieNode x, int c) {
            while (true) {
                if (x.next[c] != null) return x.next[c];
                if (x == root) break;
                x = x.suffix;
            }
            return root;
        }

        // After inserting all the words into trie, call build() function
        // to build the AC Automation.
        public void build() {
            Deque<TrieNode> q = new ArrayDeque<>();
            q.add(root);

            while (!q.isEmpty()) {
                TrieNode cur = q.pollFirst();
                for (int i = 0; i < 26; i++) {
                    if (cur.next[i] == null) continue;
                    TrieNode node = cur.next[i];
                    if (cur == root) {
                        node.suffix = root;
                    } else {
                        node.suffix = getSuffixChild(cur.suffix, i);

                        if (node.src == null) {
                            node.src = node.suffix.src;
                        }
                    }
                    q.add(node);
                }
            }
        }

        // Return the longest word that matches the current suffix
        public String search(char ch) {
            curSearchNode = getSuffixChild(curSearchNode, ch - 'a');
            if (curSearchNode.src == null) return null;
            else return curSearchNode.src.word;
        }

        // Return the longest word that matches the current suffix
        public int searchAndGetLength(char ch) {
            curSearchNode = getSuffixChild(curSearchNode, ch - 'a');
            return curSearchNode.depth;
        }

        // Return all words in the dict that are contained in the current suffix.
        // If there is no word, return an empty List (not null).
        public List<String> searchAll(char ch) {
            curSearchNode = getSuffixChild(curSearchNode, ch - 'a');
            TrieNode cur = curSearchNode.src;
            List<String> ans = new ArrayList<>();
            while (cur != null) {
                ans.add(cur.word);
                cur = cur.suffix.src;
            }
            return ans;
        }

        // Example usage code from LC 1032
        static class StreamChecker {

            ACAutomation ac = new ACAutomation();

            public StreamChecker(String[] words) {
                for (int i = 0; i < words.length; i++) {
                    ac.insert(words[i]);
                }
                ac.build();
            }

            public boolean query(char letter) {
                String word = ac.search(letter);
                return word != null;
            }
        }
    }

    public int minValidStrings(String[] words, String target) {
        int n = target.length();
        ACAutomation ac = new ACAutomation();
        for (int i = 0; i < words.length; i++) {
            ac.insert(words[i]);
        }
        ac.build();

        int[] dp = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            int len = ac.searchAndGetLength(target.charAt(i - 1));
            if (len == 0) return -1;
            dp[i] = dp[i - len] + 1;
        }
        return dp[n];
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1390513219
IphoneX,hahahiehie,11,3559,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    //    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    //    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static class ACAutomation {
        private static class TrieNode {
            TrieNode[] next = new TrieNode[26];
            // suffix node that is the longest suffix of current node.
            TrieNode suffix = null;
            // source node that contains a word.
            TrieNode src = null;
            String word = null;
            int depth = 0;
        }

        private TrieNode root = new TrieNode();
        private TrieNode curSearchNode = root;

        // DO NOT insert empty word ("""").
        public void insert(String word) {
            TrieNode cur = root;
            for (int i = 0; i < word.length(); i++) {
                int c = word.charAt(i) - 'a';
                if (cur.next[c] == null) {
                    cur.next[c] = new TrieNode();
                }
                cur = cur.next[c];
                cur.depth = i + 1;
            }
            cur.src = cur;
            cur.word = word;
        }

        private TrieNode getSuffixChild(TrieNode x, int c) {
            while (true) {
                if (x.next[c] != null) return x.next[c];
                if (x == root) break;
                x = x.suffix;
            }
            return root;
        }

        // After inserting all the words into trie, call build() function
        // to build the AC Automation.
        public void build() {
            Deque<TrieNode> q = new ArrayDeque<>();
            q.add(root);

            while (!q.isEmpty()) {
                TrieNode cur = q.pollFirst();
                for (int i = 0; i < 26; i++) {
                    if (cur.next[i] == null) continue;
                    TrieNode node = cur.next[i];
                    if (cur == root) {
                        node.suffix = root;
                    } else {
                        node.suffix = getSuffixChild(cur.suffix, i);

                        if (node.src == null) {
                            node.src = node.suffix.src;
                        }
                    }
                    q.add(node);
                }
            }
        }

        // Return the longest word that matches the current suffix
        public String search(char ch) {
            curSearchNode = getSuffixChild(curSearchNode, ch - 'a');
            if (curSearchNode.src == null) return null;
            else return curSearchNode.src.word;
        }

        // Return the longest word that matches the current suffix
        public int searchAndGetLength(char ch) {
            curSearchNode = getSuffixChild(curSearchNode, ch - 'a');
            return curSearchNode.depth;
        }

        // Return all words in the dict that are contained in the current suffix.
        // If there is no word, return an empty List (not null).
        public List<String> searchAll(char ch) {
            curSearchNode = getSuffixChild(curSearchNode, ch - 'a');
            TrieNode cur = curSearchNode.src;
            List<String> ans = new ArrayList<>();
            while (cur != null) {
                ans.add(cur.word);
                cur = cur.suffix.src;
            }
            return ans;
        }

        // Example usage code from LC 1032
        static class StreamChecker {

            ACAutomation ac = new ACAutomation();

            public StreamChecker(String[] words) {
                for (int i = 0; i < words.length; i++) {
                    ac.insert(words[i]);
                }
                ac.build();
            }

            public boolean query(char letter) {
                String word = ac.search(letter);
                return word != null;
            }
        }
    }

    public int minValidStrings(String[] words, String target) {
        int n = target.length();
        ACAutomation ac = new ACAutomation();
        for (int i = 0; i < words.length; i++) {
            ac.insert(words[i]);
        }
        ac.build();

        int[] dp = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            int len = ac.searchAndGetLength(target.charAt(i - 1));
            if (len == 0) return -1;
            dp[i] = dp[i - len] + 1;
        }
        return dp[n];
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1390513546
IphoneX,hahahiehie,11,3581,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    //    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    //    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    public int[] getSneakyNumbers(int[] nums) {
        int n = nums.length;
        int[] count = new int[101];
        
        for (int i = 0; i < n; i++) {
            count[nums[i]]++;
        }
        int[] ans = new int[2];
        int len = 0;
        for (int i = 0; i < count.length; i++) {
            if (count[i] == 2) {
                ans[len++] = i;
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1390479361
fmota,fmota,13,3518,cpp,"class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        using ll = long long;
        int n = b.size();
        vector<ll> dp(5, -(1ll<<60));
        dp[0] = 0;
        for(int i = 0; i < n; i++){
            vector<ll> ndp = dp;
            for(int j = 0; j < 4; j++){
                ndp[j + 1] = max(ndp[j + 1], dp[j] + ll(a[j]) * b[i]);
            }
            dp = ndp;
        }
        return dp.back();
    }
};",1390486460
fmota,fmota,13,3557,cpp,"using ll = long long;
template<typename T> struct rmq {
	vector<T> v;
	int n; static const int b = 30;
	vector<int> mask, t;

	int op(int x, int y) { return v[x] <= v[y] ? x : y; }
	int msb(int x) { return __builtin_clz(1)-__builtin_clz(x); }
	int small(int r, int sz = b) { return r-msb(mask[r]&((1<<sz)-1)); }
	rmq() {}
	rmq(const vector<T>& v_) : v(v_), n(v.size()), mask(n), t(n) {
		for (int i = 0, at = 0; i < n; mask[i++] = at |= 1) {
			at = (at<<1)&((1<<b)-1);
			while (at and op(i-msb(at&-at), i) == i) at ^= at&-at;
		}
		for (int i = 0; i < n/b; i++) t[i] = small(b*i+b-1);
		for (int j = 1; (1<<j) <= n/b; j++) for (int i = 0; i+(1<<j) <= n/b; i++)
			t[n/b*j+i] = op(t[n/b*(j-1)+i], t[n/b*(j-1)+i+(1<<(j-1))]);
	}
	int index_query(int l, int r) {
		if (r-l+1 <= b) return small(r, r-l+1);
		int x = l/b+1, y = r/b-1;
		if (x > y) return op(small(l+b-1), small(r));
		int j = msb(y-x+1);
		int ans = op(small(l+b-1), op(t[n/b*j+x], t[n/b*j+y-(1<<j)+1]));
		return op(ans, small(r));
	}
	T query(int l, int r) { return v[index_query(l, r)]; }
};

struct suffix_array {
	string s;
	int n;
	vector<int> sa, cnt, rnk, lcp;
	rmq<int> RMQ;

	bool cmp(int a1, int b1, int a2, int b2, int a3=0, int b3=0) {
		return a1 != b1 ? a1 < b1 : (a2 != b2 ? a2 < b2 : a3 < b3);
	}
	template<typename T> void radix(int* fr, int* to, T* r, int N, int k) {
		cnt = vector<int>(k+1, 0);
		for (int i = 0; i < N; i++) cnt[r[fr[i]]]++;
		for (int i = 1; i <= k; i++) cnt[i] += cnt[i-1];
		for (int i = N-1; i+1; i--) to[--cnt[r[fr[i]]]] = fr[i];
	}
	void rec(vector<int>& v, int k) {
		auto &tmp = rnk, &m0 = lcp;
		int N = v.size()-3, sz = (N+2)/3, sz2 = sz+N/3;
		vector<int> R(sz2+3);
		for (int i = 1, j = 0; j < sz2; i += i%3) R[j++] = i;

		radix(&R[0], &tmp[0], &v[0]+2, sz2, k);
		radix(&tmp[0], &R[0], &v[0]+1, sz2, k);
		radix(&R[0], &tmp[0], &v[0]+0, sz2, k);

		int dif = 0;
		int l0 = -1, l1 = -1, l2 = -1;
		for (int i = 0; i < sz2; i++) {
			if (v[tmp[i]] != l0 or v[tmp[i]+1] != l1 or v[tmp[i]+2] != l2)
				l0 = v[tmp[i]], l1 = v[tmp[i]+1], l2 = v[tmp[i]+2], dif++;
			if (tmp[i]%3 == 1) R[tmp[i]/3] = dif;
			else R[tmp[i]/3+sz] = dif;
		}

		if (dif < sz2) {
			rec(R, dif);
			for (int i = 0; i < sz2; i++) R[sa[i]] = i+1;
		} else for (int i = 0; i < sz2; i++) sa[R[i]-1] = i;

		for (int i = 0, j = 0; j < sz2; i++) if (sa[i] < sz) tmp[j++] = 3*sa[i];
		radix(&tmp[0], &m0[0], &v[0], sz, k);
		for (int i = 0; i < sz2; i++)
			sa[i] = sa[i] < sz ? 3*sa[i]+1 : 3*(sa[i]-sz)+2;

		int at = sz2+sz-1, p = sz-1, p2 = sz2-1;
		while (p >= 0 and p2 >= 0) {
			if ((sa[p2]%3==1 and cmp(v[m0[p]], v[sa[p2]], R[m0[p]/3],
				R[sa[p2]/3+sz])) or (sa[p2]%3==2 and cmp(v[m0[p]], v[sa[p2]],
				v[m0[p]+1], v[sa[p2]+1], R[m0[p]/3+sz], R[sa[p2]/3+1])))
				sa[at--] = sa[p2--];
			else sa[at--] = m0[p--];
		}
		while (p >= 0) sa[at--] = m0[p--];
		if (N%3==1) for (int i = 0; i < N; i++) sa[i] = sa[i+1];
	}

	suffix_array(const string& s_) : s(s_), n(s.size()), sa(n+3),
			cnt(n+1), rnk(n), lcp(n-1) {
		vector<int> v(n+3);
		for (int i = 0; i < n; i++) v[i] = i;
		radix(&v[0], &rnk[0], &s[0], n, 256);
		int dif = 1;
		for (int i = 0; i < n; i++)
			v[rnk[i]] = dif += (i and s[rnk[i]] != s[rnk[i-1]]);
		if (n >= 2) rec(v, dif);
		sa.resize(n);

		for (int i = 0; i < n; i++) rnk[sa[i]] = i;
		for (int i = 0, k = 0; i < n; i++, k -= !!k) {
			if (rnk[i] == n-1) {
				k = 0;
				continue;
			}
			int j = sa[rnk[i]+1];
			while (i+k < n and j+k < n and s[i+k] == s[j+k]) k++;
			lcp[rnk[i]] = k;
		}
		RMQ = rmq<int>(lcp);
	}

	int query(int i, int j) {
		if (i == j) return n-i;
		i = rnk[i], j = rnk[j];
		return RMQ.query(min(i, j), max(i, j)-1);
	}
	pair<int, int> next(int L, int R, int i, char c) {
		int l = L, r = R+1;
		while (l < r) {
			int m = (l+r)/2;
			if (i+sa[m] >= n or s[i+sa[m]] < c) l = m+1;
			else r = m;
		}
		if (l == R+1 or s[i+sa[l]] > c) return {-1, -1};
		L = l;

		l = L, r = R+1;
		while (l < r) {
			int m = (l+r)/2;
			if (i+sa[m] >= n or s[i+sa[m]] <= c) l = m+1;
			else r = m;
		}
		R = l-1;
		return {L, R};
	}
	// quantas vezes 't' ocorre em 's' - O(|t| log n)
	int count_substr(string& t) {
		int L = 0, R = n-1;
		for (int i = 0; i < t.size(); i++) {
			tie(L, R) = next(L, R, i, t[i]);
			if (L == -1) return 0;
		}
		return R-L+1;
	}

	// exemplo de f que resolve o problema
	// https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/D
	ll f(ll k) { return k*(k+1)/2; }

	ll dfs(int L, int R, int p) { // dfs na suffix tree chamado em pre ordem
		int ext = L != R ? RMQ.query(L, R-1) : n - sa[L];

		// Tem 'ext - p' substrings diferentes que ocorrem 'R-L+1' vezes
		// O LCP de todas elas eh 'ext'
		ll ans = (ext-p)*f(R-L+1);

		// L eh terminal, e folha sse L == R
		if (sa[L]+ext == n) L++;

		// se for um SA de varias strings separadas como s#t$u&, usar no lugar do if de cima
		//	(separadores < 'a', diferentes e inclusive no final)
		// while (L <= R && (sa[L]+ext == n || s[sa[L]+ext] < 'a')) {
		//   L++;
		// }

		while (L <= R) {
			int idx = L != R ? RMQ.index_query(L, R-1) : -1;
			if (idx == -1 or lcp[idx] != ext) idx = R;

			ans += dfs(L, idx, ext);
			L = idx+1;
		}
		return ans;
	}

	// sum over substrings: computa, para toda substring t distinta de s,
	// \sum f(# ocorrencias de t em s) - O (n)
	ll sos() { return dfs(0, n-1, 0); }
};

class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        string all;
        for(auto c : target){
            all.push_back(c);
        }
        set<int> good;
        int n = target.size();
        all.push_back('0');
        for(auto word : words){
            good.insert(all.size());
            for(auto c : word) all.push_back(c);
            all.push_back('1');
        }
        int last = -1;
        vector<int> mx(n);
        suffix_array sa(all);
        int todo = all.size();
        for(int i = 0; i < todo; i++){
            if(sa.sa[i] < n){
                if(last != -1){
                    mx[sa.sa[i]] = max(mx[sa.sa[i]], sa.query(last, sa.sa[i]));
                }
            } else if(good.count(sa.sa[i])){
                last = sa.sa[i];
            }
        }
        last = -1;
        for(int i = todo - 1; i >= 0; i--){
            if(sa.sa[i] < n){
                if(last != -1){
                    mx[sa.sa[i]] = max(mx[sa.sa[i]], sa.query(last, sa.sa[i]));
                }
            } else if(good.count(sa.sa[i])){
                last = sa.sa[i];
            }
        }
        const int inf = 1<<30;
        vector<int> dp(n + 1, inf);
        dp[0] = 0;
        using pii = pair<int, int>;
        vector<vector<pii>> adj(n + 1);
        for(int i = 0; i < n; i++){
            if(i){
                adj[i].emplace_back(i - 1, 0);
            }
            if(mx[i] > 0){
                adj[i].emplace_back(pii(min(i + mx[i], n), 1));
            }
        }
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        pq.push(pii(dp[0], 0));
        while(!pq.empty()){
            auto [d, u] = pq.top();
            pq.pop();
            if(dp[u] != d) continue;
            for(auto [v, w] : adj[u]){
                if(dp[v] > dp[u] + w){
                    dp[v] = dp[u] + w;
                    pq.push(pii(dp[v], v));
                }
            }
        }
        if(dp.back() == inf) return -1;
        return dp.back();
    }
};",1390504195
fmota,fmota,13,3559,cpp,"using ll = long long;
template<typename T> struct rmq {
	vector<T> v;
	int n; static const int b = 30;
	vector<int> mask, t;

	int op(int x, int y) { return v[x] <= v[y] ? x : y; }
	int msb(int x) { return __builtin_clz(1)-__builtin_clz(x); }
	int small(int r, int sz = b) { return r-msb(mask[r]&((1<<sz)-1)); }
	rmq() {}
	rmq(const vector<T>& v_) : v(v_), n(v.size()), mask(n), t(n) {
		for (int i = 0, at = 0; i < n; mask[i++] = at |= 1) {
			at = (at<<1)&((1<<b)-1);
			while (at and op(i-msb(at&-at), i) == i) at ^= at&-at;
		}
		for (int i = 0; i < n/b; i++) t[i] = small(b*i+b-1);
		for (int j = 1; (1<<j) <= n/b; j++) for (int i = 0; i+(1<<j) <= n/b; i++)
			t[n/b*j+i] = op(t[n/b*(j-1)+i], t[n/b*(j-1)+i+(1<<(j-1))]);
	}
	int index_query(int l, int r) {
		if (r-l+1 <= b) return small(r, r-l+1);
		int x = l/b+1, y = r/b-1;
		if (x > y) return op(small(l+b-1), small(r));
		int j = msb(y-x+1);
		int ans = op(small(l+b-1), op(t[n/b*j+x], t[n/b*j+y-(1<<j)+1]));
		return op(ans, small(r));
	}
	T query(int l, int r) { return v[index_query(l, r)]; }
};

struct suffix_array {
	string s;
	int n;
	vector<int> sa, cnt, rnk, lcp;
	rmq<int> RMQ;

	bool cmp(int a1, int b1, int a2, int b2, int a3=0, int b3=0) {
		return a1 != b1 ? a1 < b1 : (a2 != b2 ? a2 < b2 : a3 < b3);
	}
	template<typename T> void radix(int* fr, int* to, T* r, int N, int k) {
		cnt = vector<int>(k+1, 0);
		for (int i = 0; i < N; i++) cnt[r[fr[i]]]++;
		for (int i = 1; i <= k; i++) cnt[i] += cnt[i-1];
		for (int i = N-1; i+1; i--) to[--cnt[r[fr[i]]]] = fr[i];
	}
	void rec(vector<int>& v, int k) {
		auto &tmp = rnk, &m0 = lcp;
		int N = v.size()-3, sz = (N+2)/3, sz2 = sz+N/3;
		vector<int> R(sz2+3);
		for (int i = 1, j = 0; j < sz2; i += i%3) R[j++] = i;

		radix(&R[0], &tmp[0], &v[0]+2, sz2, k);
		radix(&tmp[0], &R[0], &v[0]+1, sz2, k);
		radix(&R[0], &tmp[0], &v[0]+0, sz2, k);

		int dif = 0;
		int l0 = -1, l1 = -1, l2 = -1;
		for (int i = 0; i < sz2; i++) {
			if (v[tmp[i]] != l0 or v[tmp[i]+1] != l1 or v[tmp[i]+2] != l2)
				l0 = v[tmp[i]], l1 = v[tmp[i]+1], l2 = v[tmp[i]+2], dif++;
			if (tmp[i]%3 == 1) R[tmp[i]/3] = dif;
			else R[tmp[i]/3+sz] = dif;
		}

		if (dif < sz2) {
			rec(R, dif);
			for (int i = 0; i < sz2; i++) R[sa[i]] = i+1;
		} else for (int i = 0; i < sz2; i++) sa[R[i]-1] = i;

		for (int i = 0, j = 0; j < sz2; i++) if (sa[i] < sz) tmp[j++] = 3*sa[i];
		radix(&tmp[0], &m0[0], &v[0], sz, k);
		for (int i = 0; i < sz2; i++)
			sa[i] = sa[i] < sz ? 3*sa[i]+1 : 3*(sa[i]-sz)+2;

		int at = sz2+sz-1, p = sz-1, p2 = sz2-1;
		while (p >= 0 and p2 >= 0) {
			if ((sa[p2]%3==1 and cmp(v[m0[p]], v[sa[p2]], R[m0[p]/3],
				R[sa[p2]/3+sz])) or (sa[p2]%3==2 and cmp(v[m0[p]], v[sa[p2]],
				v[m0[p]+1], v[sa[p2]+1], R[m0[p]/3+sz], R[sa[p2]/3+1])))
				sa[at--] = sa[p2--];
			else sa[at--] = m0[p--];
		}
		while (p >= 0) sa[at--] = m0[p--];
		if (N%3==1) for (int i = 0; i < N; i++) sa[i] = sa[i+1];
	}

	suffix_array(const string& s_) : s(s_), n(s.size()), sa(n+3),
			cnt(n+1), rnk(n), lcp(n-1) {
		vector<int> v(n+3);
		for (int i = 0; i < n; i++) v[i] = i;
		radix(&v[0], &rnk[0], &s[0], n, 256);
		int dif = 1;
		for (int i = 0; i < n; i++)
			v[rnk[i]] = dif += (i and s[rnk[i]] != s[rnk[i-1]]);
		if (n >= 2) rec(v, dif);
		sa.resize(n);

		for (int i = 0; i < n; i++) rnk[sa[i]] = i;
		for (int i = 0, k = 0; i < n; i++, k -= !!k) {
			if (rnk[i] == n-1) {
				k = 0;
				continue;
			}
			int j = sa[rnk[i]+1];
			while (i+k < n and j+k < n and s[i+k] == s[j+k]) k++;
			lcp[rnk[i]] = k;
		}
		RMQ = rmq<int>(lcp);
	}

	int query(int i, int j) {
		if (i == j) return n-i;
		i = rnk[i], j = rnk[j];
		return RMQ.query(min(i, j), max(i, j)-1);
	}
	pair<int, int> next(int L, int R, int i, char c) {
		int l = L, r = R+1;
		while (l < r) {
			int m = (l+r)/2;
			if (i+sa[m] >= n or s[i+sa[m]] < c) l = m+1;
			else r = m;
		}
		if (l == R+1 or s[i+sa[l]] > c) return {-1, -1};
		L = l;

		l = L, r = R+1;
		while (l < r) {
			int m = (l+r)/2;
			if (i+sa[m] >= n or s[i+sa[m]] <= c) l = m+1;
			else r = m;
		}
		R = l-1;
		return {L, R};
	}
	// quantas vezes 't' ocorre em 's' - O(|t| log n)
	int count_substr(string& t) {
		int L = 0, R = n-1;
		for (int i = 0; i < t.size(); i++) {
			tie(L, R) = next(L, R, i, t[i]);
			if (L == -1) return 0;
		}
		return R-L+1;
	}

	// exemplo de f que resolve o problema
	// https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/D
	ll f(ll k) { return k*(k+1)/2; }

	ll dfs(int L, int R, int p) { // dfs na suffix tree chamado em pre ordem
		int ext = L != R ? RMQ.query(L, R-1) : n - sa[L];

		// Tem 'ext - p' substrings diferentes que ocorrem 'R-L+1' vezes
		// O LCP de todas elas eh 'ext'
		ll ans = (ext-p)*f(R-L+1);

		// L eh terminal, e folha sse L == R
		if (sa[L]+ext == n) L++;

		// se for um SA de varias strings separadas como s#t$u&, usar no lugar do if de cima
		//	(separadores < 'a', diferentes e inclusive no final)
		// while (L <= R && (sa[L]+ext == n || s[sa[L]+ext] < 'a')) {
		//   L++;
		// }

		while (L <= R) {
			int idx = L != R ? RMQ.index_query(L, R-1) : -1;
			if (idx == -1 or lcp[idx] != ext) idx = R;

			ans += dfs(L, idx, ext);
			L = idx+1;
		}
		return ans;
	}

	// sum over substrings: computa, para toda substring t distinta de s,
	// \sum f(# ocorrencias de t em s) - O (n)
	ll sos() { return dfs(0, n-1, 0); }
};

class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        string all;
        for(auto c : target){
            all.push_back(c);
        }
        set<int> good;
        int n = target.size();
        all.push_back('0');
        for(auto word : words){
            good.insert(all.size());
            for(auto c : word) all.push_back(c);
            all.push_back('1');
        }
        int last = -1;
        vector<int> mx(n);
        suffix_array sa(all);
        int todo = all.size();
        for(int i = 0; i < todo; i++){
            if(sa.sa[i] < n){
                if(last != -1){
                    mx[sa.sa[i]] = max(mx[sa.sa[i]], sa.query(last, sa.sa[i]));
                }
            } else if(good.count(sa.sa[i])){
                last = sa.sa[i];
            }
        }
        last = -1;
        for(int i = todo - 1; i >= 0; i--){
            if(sa.sa[i] < n){
                if(last != -1){
                    mx[sa.sa[i]] = max(mx[sa.sa[i]], sa.query(last, sa.sa[i]));
                }
            } else if(good.count(sa.sa[i])){
                last = sa.sa[i];
            }
        }
        const int inf = 1<<30;
        vector<int> dp(n + 1, inf);
        dp[0] = 0;
        using pii = pair<int, int>;
        vector<vector<pii>> adj(n + 1);
        for(int i = 0; i < n; i++){
            if(i){
                adj[i].emplace_back(i - 1, 0);
            }
            if(mx[i] > 0){
                adj[i].emplace_back(pii(min(i + mx[i], n), 1));
            }
        }
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        pq.push(pii(dp[0], 0));
        while(!pq.empty()){
            auto [d, u] = pq.top();
            pq.pop();
            if(dp[u] != d) continue;
            for(auto [v, w] : adj[u]){
                if(dp[v] > dp[u] + w){
                    dp[v] = dp[u] + w;
                    pq.push(pii(dp[v], v));
                }
            }
        }
        if(dp.back() == inf) return -1;
        return dp.back();
    }
};",1390505658
fmota,fmota,13,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        set<int> seen;
        vector<int> res;
        for(int v : nums){
            if(seen.count(v)) res.push_back(v);
            seen.insert(v);
        }
        return res;
    }
};",1390477650
Yang Xiao,sheepforever,15,3518,cpp,"const long long INF = 0x3F3F3F3F3F3F3FLL;

class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        vector<vector<long long>> minV(n + 1, vector<long long>(5, INF));
        vector<vector<long long>> maxV(n + 1, vector<long long>(5, -INF));
        
        minV[0][0] = maxV[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= 4; ++j) {
                maxV[i + 1][j] = max(maxV[i + 1][j], maxV[i][j]);
                minV[i + 1][j] = min(minV[i + 1][j], minV[i][j]);
                if (j + 1 <= 4) {
                    if (maxV[i][j] != -INF) {
                        maxV[i + 1][j + 1] = max(maxV[i + 1][j + 1], maxV[i][j] + a[j] * 1LL * b[i]);
                    }
                    if (minV[i][j] != -INF) {
                        minV[i + 1][j + 1] = min(minV[i + 1][j + 1], minV[i][j] + a[j] * 1LL * b[i]);
                    }
                }
            }
        }
        return maxV[n][4];
    }
};",1390490468
Yang Xiao,sheepforever,15,3557,cpp,"/*5.扩展KMP（不太熟悉，HZH的模板）
//next数组指串T的后缀与自身的最长公共前缀
//lcp指S的后缀与T的最长公共前缀，既KMP的加强版。
//扩展KMP可以算出S以i结尾的串能和子串匹配的最长长度。
//这里的next指函数next[i] = |T与T(i,m)的最长公共前缀|，这里2<i<m。
*/
void next_function(char S[], int n, int next[])
{
    next[0] = n;
    int j = 0, k = 1;
    while(1+j<n && S[j] == S[1+j]) j++;
    next[1] = j;
    for(int i=2; i<n; ++i)
    {
        int len = k + next[k] - 1;
        int l = next[i - k];
        if(l < len - i + 1) next[i] = l;
        else
        {
            int j = max(0, len - i + 1);
            while(S[i+j] == S[j] && i + j < n) j++;
            next[i] = j;
            k = i;
        }
    }
}
void extend_kmp(char S[], int n, char T[], int m, int next[], int lcp[])
{
    next_function(T, m, next);
    int j = 0, k = 0;
    while(j<min(n, m) && T[j] == S[j]) ++j;
    lcp[0] = j;
    for(int i=1; i<n; ++i)
    {
        int len = k + lcp[k] - 1;
        int l = next[i - k];
        if(l < len - i + 1) lcp[i] = l;
        else
        {
            int j = max(0, len - i + 1);
            while(i+j<n && j<m && S[i+j]==T[j]) j++;
            lcp[i] = j;
            k = i;
        }
    }
}

const int N = 100007;

vector<int> lcp(string s, string t) {
    static char S[N], T[N];
    static int next[N], lcp[N];
    int n = s.size();
    for (int i = 0; i < n; ++i) {
        S[i] = s[i];
    }
    int m = t.size();
    for (int i = 0; i < m; ++i) {
        T[i] = t[i];
    }
    extend_kmp(S, n, T, m, next, lcp);
    return vector<int>(lcp, lcp + n);
}

const int INF = 0x3F3F3F3F;
int a[N];

void add(int x, int y) {
    ++x;
    while (x < N) {
        a[x] = min(a[x], y);
        x += x & -x;
    }
}

int getMin(int x) {
    ++x;
    int ret = INF;
    while (x) {
        ret = min(ret, a[x]);
        x -= x & -x;
    }
    return ret;
}

class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = words.size();
        vector<vector<int>> common(n);
        for (int i = 0; i < n; ++i) {
            common[i] = lcp(target, words[i]);
        }
        
        int len = target.size();
        for (int i = 0; i <= len + 10; ++i) {
            a[i] = INF;
        }
        vector<int> dp(len + 1, INF);
        dp[len] = 0;
        add(len, 0);
        for (int i = len - 1; i >= 0; --i) {
            int res = 0;
            for (int j = 0; j < n; ++j) {
                res = max(res, common[j][i]);
            }
            
            dp[i] = min(dp[i], getMin(i + res) + 1);
            assert(i + res <= len);
            add(i, dp[i]);
        }
        return dp[0] >= INF ? -1 : dp[0];
    }
};",1390513765
Yang Xiao,sheepforever,15,3559,cpp,"/*5.扩展KMP（不太熟悉，HZH的模板）
//next数组指串T的后缀与自身的最长公共前缀
//lcp指S的后缀与T的最长公共前缀，既KMP的加强版。
//扩展KMP可以算出S以i结尾的串能和子串匹配的最长长度。
//这里的next指函数next[i] = |T与T(i,m)的最长公共前缀|，这里2<i<m。
*/
void next_function(char S[], int n, int next[])
{
    next[0] = n;
    int j = 0, k = 1;
    while(1+j<n && S[j] == S[1+j]) j++;
    next[1] = j;
    for(int i=2; i<n; ++i)
    {
        int len = k + next[k] - 1;
        int l = next[i - k];
        if(l < len - i + 1) next[i] = l;
        else
        {
            int j = max(0, len - i + 1);
            while(S[i+j] == S[j] && i + j < n) j++;
            next[i] = j;
            k = i;
        }
    }
}
void extend_kmp(char S[], int n, char T[], int m, int next[], int lcp[])
{
    next_function(T, m, next);
    int j = 0, k = 0;
    while(j<min(n, m) && T[j] == S[j]) ++j;
    lcp[0] = j;
    for(int i=1; i<n; ++i)
    {
        int len = k + lcp[k] - 1;
        int l = next[i - k];
        if(l < len - i + 1) lcp[i] = l;
        else
        {
            int j = max(0, len - i + 1);
            while(i+j<n && j<m && S[i+j]==T[j]) j++;
            lcp[i] = j;
            k = i;
        }
    }
}

const int N = 100007;

vector<int> lcp(string s, string t) {
    static char S[N], T[N];
    static int next[N], lcp[N];
    int n = s.size();
    for (int i = 0; i < n; ++i) {
        S[i] = s[i];
    }
    int m = t.size();
    for (int i = 0; i < m; ++i) {
        T[i] = t[i];
    }
    extend_kmp(S, n, T, m, next, lcp);
    return vector<int>(lcp, lcp + n);
}

const int INF = 0x3F3F3F3F;
int a[N];

void add(int x, int y) {
    ++x;
    while (x < N) {
        a[x] = min(a[x], y);
        x += x & -x;
    }
}

int getMin(int x) {
    ++x;
    int ret = INF;
    while (x) {
        ret = min(ret, a[x]);
        x -= x & -x;
    }
    return ret;
}

class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = words.size();
        vector<vector<int>> common(n);
        for (int i = 0; i < n; ++i) {
            common[i] = lcp(target, words[i]);
        }
        
        int len = target.size();
        for (int i = 0; i <= len + 10; ++i) {
            a[i] = INF;
        }
        vector<int> dp(len + 1, INF);
        dp[len] = 0;
        add(len, 0);
        for (int i = len - 1; i >= 0; --i) {
            int res = 0;
            for (int j = 0; j < n; ++j) {
                res = max(res, common[j][i]);
            }
            
            dp[i] = min(dp[i], getMin(i + res) + 1);
            assert(i + res <= len);
            add(i, dp[i]);
        }
        return dp[0] >= INF ? -1 : dp[0];
    }
};",1390514750
Yang Xiao,sheepforever,15,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        map<int, int> count;
        for (auto x : nums) {
            count[x]++;
        }
        vector<int> ans;
        for (auto [x, res] : count) {
            if (res == 2) {
                ans.push_back(x);
            }
        }
        return ans;
    }
};",1390478073
kmjp,kmjp,17,3518,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------



ll from[5];
ll to[5];

class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int i,j,N=b.size();
        FOR(i,5) from[i]=-1LL<<60;
        from[0]=0;
        FOR(i,N) {
			FOR(j,5) to[j]=from[j];
			FOR(j,4) to[j+1]=max(to[j+1],from[j]+1LL*a[j]*b[i]);
			swap(from,to);
		}
        return from[4];
    }
};
",1390486024
kmjp,kmjp,17,3557,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

unordered_set<ll> S[50505];

using VT = string;

struct RollingHash {
	static const ll mo0=1000000021,mo1=1000000009;
	static ll mul0,mul1;
	static const ll add0=1000010007, add1=1003333331;
	static vector<ll> pmo[2];
	VT s; int l; vector<ll> hash_[2];
	void init(VT s) {
		this->s=s; l=s.size(); int i,j;
		hash_[0]=hash_[1]=vector<ll>(1,0);
		if(!mul0) mul0=10009+(((ll)&mul0+time(NULL))>>5)%1259,mul1=10007+(time(NULL)+((ll)&mul1)>>5)%2257;
		if(pmo[0].empty()) pmo[0].push_back(1),pmo[1].push_back(1);
		FOR(i,l) hash_[0].push_back((hash_[0].back()*mul0+add0+s[i])%mo0);
		FOR(i,l) hash_[1].push_back((hash_[1].back()*mul1+add1+s[i])%mo1);
	}
	/*以下ll版*/
	ll hash(int l,int r) { // s[l..r]
		if(l>r) return 0;
		while(pmo[0].size()<r+2)
			pmo[0].push_back(pmo[0].back()*mul0%mo0), pmo[1].push_back(pmo[1].back()*mul1%mo1);
		return (((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0)<<32) | 
			             ((hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);
	}
	ll hash(VT s) { init(s); return hash(0,s.size()-1); }
	static ll concat(ll L ,ll R,int RL) { // hash(L+R) RL=len-of-R
		while(pmo[0].size()<RL+2) pmo[0].push_back(pmo[0].back()*mul0%mo0), pmo[1].push_back(pmo[1].back()*mul1%mo1);
		ll La=L>>32,Lb=(L<<32)>>32,Ra=R>>32,Rb=(R<<32)>>32;
		return (((Ra + La*pmo[0][RL])%mo0)<<32)|((Rb + Lb*pmo[1][RL])%mo1);
	}
};
vector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;

RollingHash rh;
int dp[50505];
vector<pair<int,int>> E[50505];


class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
		int i,j,N=target.size();
		FOR(i,50501) S[i].clear(),E[i].clear(),dp[i]=1<<20;
		dp[0]=0;
		FOR(i,N) E[i+1].push_back({i,0});
		
		FORR(w,words) {
			rh.init(w);
			for(i=1;i<=w.size();i++) S[i].insert(rh.hash(0,i-1));
		}
		rh.init(target);
		FOR(i,N) {
			int len=0;
			for(j=20;j>=0;j--) if(i+len+(1<<j)<=N&&S[len+(1<<j)].count(rh.hash(i,i+len+(1<<j)-1))) len+=(1<<j);
			if(len) E[i].push_back({i+len,1});
		}
		
		priority_queue<pair<int,int>> Q;
		Q.push({0,0});
		while(Q.size()) {
			int co=-Q.top().first;
			int cur=Q.top().second;
			Q.pop();
			FORR(e,E[cur]) if(dp[e.first]>co+e.second) {
				dp[e.first]=co+e.second;
				Q.push({-dp[e.first],e.first});
			}
			
		}
		if(dp[N]>=1<<20) return -1;
		return dp[N];
        
    }
};
",1390509131
kmjp,kmjp,17,3559,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

unordered_set<ll> S[50505];

using VT = string;

struct RollingHash {
	static const ll mo0=1000000021,mo1=1000000009;
	static ll mul0,mul1;
	static const ll add0=1000010007, add1=1003333331;
	static vector<ll> pmo[2];
	VT s; int l; vector<ll> hash_[2];
	void init(VT s) {
		this->s=s; l=s.size(); int i,j;
		hash_[0]=hash_[1]=vector<ll>(1,0);
		if(!mul0) mul0=10009+(((ll)&mul0+time(NULL))>>5)%1259,mul1=10007+(time(NULL)+((ll)&mul1)>>5)%2257;
		if(pmo[0].empty()) pmo[0].push_back(1),pmo[1].push_back(1);
		FOR(i,l) hash_[0].push_back((hash_[0].back()*mul0+add0+s[i])%mo0);
		FOR(i,l) hash_[1].push_back((hash_[1].back()*mul1+add1+s[i])%mo1);
	}
	/*以下ll版*/
	ll hash(int l,int r) { // s[l..r]
		if(l>r) return 0;
		while(pmo[0].size()<r+2)
			pmo[0].push_back(pmo[0].back()*mul0%mo0), pmo[1].push_back(pmo[1].back()*mul1%mo1);
		return (((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0)<<32) | 
			             ((hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);
	}
	ll hash(VT s) { init(s); return hash(0,s.size()-1); }
	static ll concat(ll L ,ll R,int RL) { // hash(L+R) RL=len-of-R
		while(pmo[0].size()<RL+2) pmo[0].push_back(pmo[0].back()*mul0%mo0), pmo[1].push_back(pmo[1].back()*mul1%mo1);
		ll La=L>>32,Lb=(L<<32)>>32,Ra=R>>32,Rb=(R<<32)>>32;
		return (((Ra + La*pmo[0][RL])%mo0)<<32)|((Rb + Lb*pmo[1][RL])%mo1);
	}
};
vector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;

RollingHash rh;
int dp[50505];
vector<pair<int,int>> E[50505];


class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
		int i,j,N=target.size();
		FOR(i,50501) S[i].clear(),E[i].clear(),dp[i]=1<<20;
		dp[0]=0;
		FOR(i,N) E[i+1].push_back({i,0});
		
		FORR(w,words) {
			rh.init(w);
			for(i=1;i<=w.size();i++) S[i].insert(rh.hash(0,i-1));
		}
		rh.init(target);
		FOR(i,N) {
			int len=0;
			for(j=20;j>=0;j--) if(i+len+(1<<j)<=N&&S[len+(1<<j)].count(rh.hash(i,i+len+(1<<j)-1))) len+=(1<<j);
			if(len) E[i].push_back({i+len,1});
		}
		
		priority_queue<pair<int,int>> Q;
		Q.push({0,0});
		while(Q.size()) {
			int co=-Q.top().first;
			int cur=Q.top().second;
			Q.pop();
			FORR(e,E[cur]) if(dp[e.first]>co+e.second) {
				dp[e.first]=co+e.second;
				Q.push({-dp[e.first],e.first});
			}
			
		}
		if(dp[N]>=1<<20) return -1;
		return dp[N];
        
    }
};
",1390509319
kmjp,kmjp,17,3581,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------



class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
		map<int,int> M;
		FORR(a,nums) M[a]++;
		vector<int> V;
		FORR(a,M) if(a.second==2) V.push_back(a.first);
		return V;
        
    }
};
",1390478734
waakaaka,waakaaka,18,3518,cpp,"class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        using ll = long long;
        const ll INF = 1e18;
        vector<ll> dp(5, -INF);
        dp[0] = 0;
        for (int x : b) {
            auto ndp = dp;
            for (int i = 0; i < 4; ++i) {
                ndp[i + 1] = max(ndp[i + 1], dp[i] + (ll)a[i] * x);
            }
            swap(dp, ndp);
        }
        return dp[4];
    }
};",1390487500
waakaaka,waakaaka,18,3557,cpp,"template <typename T, typename K = int>
struct Fenwick {
	int n;
	vector<T> bit;
	Fenwick() {} // For vector<Fenwick>.
	Fenwick(int _n) : n(_n), bit(n + 1) {}
	/* 0 <= p < INT_MAX - 1. */
	void update(int p, T v) {
		for (++p; p <= n; p += p & -p) bit[p] += v;
	}
	/* INT_MIN <= p < n. */
	T query(int p) {
		T ret{};
		for (++p; p > 0; p -= p & -p) ret += bit[p];
		return ret;
	}
	/* Must be addition! INT_MIN < l <= r < n. */
	T query(int l, int r) { return query(r) - query(l - 1); }
	/* Assume all values >= 0 in array.
	Find first ret in 0..n-1 so that sum[0..ret] >= k (or -1 if not exist). */
	int findFirst(T k) {
		int ret = 0, maxBit = 31 - __builtin_clz(n);
		for (int i = maxBit; i >= 0; --i) {
			int p = ret + (1 << i);
			if (p <= n && bit[p] < k) {
				k -= bit[p];
				ret = p;
			}
		}
		return ret == n ? -1 : ret;
	}
	/* For range-update/point-query, must be addition! 0 <= l <= r < INT_MAX - 2. */
	void updateRange(int l, int r, T v) {
		update(l, v);
		update(r + 1, -v);
	}
	/* For range-update/point-query, must be addition! INT_MIN <= p < n. */
	T queryPoint(int p) { return query(p); }
};
struct Min {
	int x;
	Min(int _x = numeric_limits<int>::max()) : x(_x) {}
	void operator+=(const Min& a) {
		x = min(x, a.x);
	}
};
vector<int> zalgo(const string& s) {
	// Maintain max r such that there is l <= i <= r with [l,r] being prefix substring
	int n = s.size(), l = 0, r = 0;
	vector<int> z(n);
	z[0] = n;
	for (int i = 1; i < n; ++i) {
		if (i > r) {
			l = r = i;
			while (r < n && s[r - l] == s[r]) ++r;
			z[i] = r - l;
			--r;
		} else {
			if (z[i - l] <= r - i) z[i] = z[i - l];
			else {
				l = i;
				while (r < n && s[r - l] == s[r]) ++r;
				z[i] = r - l;
				--r;
			}
		}
	}
	return z;
}
class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = words.size();
        vector<vector<int>> L(n);
        for (int i = 0; i < n; ++i) {
            L[i] = zalgo(words[i] + '$' + target);
            L[i].erase(L[i].begin(), L[i].begin() + words[i].size() + 1);
        }
        int m = target.size();
        const int INF = 1e9;
        vector<int> dp(m, INF);
        Fenwick<Min> fenw(m + 1);
        fenw.update(m, 0);
        for (int i = m - 1; i >= 0; --i) {
            for (int j = 0; j < n; ++j) {
                int lcp = L[j][i];
                int mn = fenw.query(i + lcp).x;
                if (mn != INT_MAX) dp[i] = min(dp[i], mn + 1);
            }
            fenw.update(i, dp[i]);
        }
        return dp[0] > m ? -1 : dp[0];
    }
};",1390510742
waakaaka,waakaaka,18,3559,cpp,"template <typename T, typename K = int>
struct Fenwick {
	int n;
	vector<T> bit;
	Fenwick() {} // For vector<Fenwick>.
	Fenwick(int _n) : n(_n), bit(n + 1) {}
	/* 0 <= p < INT_MAX - 1. */
	void update(int p, T v) {
		for (++p; p <= n; p += p & -p) bit[p] += v;
	}
	/* INT_MIN <= p < n. */
	T query(int p) {
		T ret{};
		for (++p; p > 0; p -= p & -p) ret += bit[p];
		return ret;
	}
	/* Must be addition! INT_MIN < l <= r < n. */
	T query(int l, int r) { return query(r) - query(l - 1); }
	/* Assume all values >= 0 in array.
	Find first ret in 0..n-1 so that sum[0..ret] >= k (or -1 if not exist). */
	int findFirst(T k) {
		int ret = 0, maxBit = 31 - __builtin_clz(n);
		for (int i = maxBit; i >= 0; --i) {
			int p = ret + (1 << i);
			if (p <= n && bit[p] < k) {
				k -= bit[p];
				ret = p;
			}
		}
		return ret == n ? -1 : ret;
	}
	/* For range-update/point-query, must be addition! 0 <= l <= r < INT_MAX - 2. */
	void updateRange(int l, int r, T v) {
		update(l, v);
		update(r + 1, -v);
	}
	/* For range-update/point-query, must be addition! INT_MIN <= p < n. */
	T queryPoint(int p) { return query(p); }
};
struct Min {
	int x;
	Min(int _x = numeric_limits<int>::max()) : x(_x) {}
	void operator+=(const Min& a) {
		x = min(x, a.x);
	}
};
vector<int> zalgo(const string& s) {
	// Maintain max r such that there is l <= i <= r with [l,r] being prefix substring
	int n = s.size(), l = 0, r = 0;
	vector<int> z(n);
	z[0] = n;
	for (int i = 1; i < n; ++i) {
		if (i > r) {
			l = r = i;
			while (r < n && s[r - l] == s[r]) ++r;
			z[i] = r - l;
			--r;
		} else {
			if (z[i - l] <= r - i) z[i] = z[i - l];
			else {
				l = i;
				while (r < n && s[r - l] == s[r]) ++r;
				z[i] = r - l;
				--r;
			}
		}
	}
	return z;
}
class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = words.size();
        vector<vector<int>> L(n);
        for (int i = 0; i < n; ++i) {
            L[i] = zalgo(words[i] + '$' + target);
            L[i].erase(L[i].begin(), L[i].begin() + words[i].size() + 1);
        }
        int m = target.size();
        const int INF = 1e9;
        vector<int> dp(m, INF);
        Fenwick<Min> fenw(m + 1);
        fenw.update(m, 0);
        for (int i = m - 1; i >= 0; --i) {
            for (int j = 0; j < n; ++j) {
                int lcp = L[j][i];
                int mn = fenw.query(i + lcp).x;
                if (mn != INT_MAX) dp[i] = min(dp[i], mn + 1);
            }
            fenw.update(i, dp[i]);
        }
        return dp[0] > m ? -1 : dp[0];
    }
};",1390511076
waakaaka,waakaaka,18,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        int n = nums.size() - 2;
        vector<int> cnt(n);
        for (int x : nums) {
            cnt[x]++;
        }
        vector<int> ret;
        for (int i = 0; i < n; ++i) {
            if (cnt[i] > 1) ret.push_back(i);
        }
        return ret;
    }
};",1390478414
LayCurse,LayCurse,19,3518,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  long long maxScore(vector<int>& a, vector<int>& b){
    int i;
    int N = b.size();
    long long dp[5];
    long long nx[5];
    for(i=(0);i<(5);i++){
      dp[i] = -4611686016279904256LL;
    }
    dp[0] = 0;
    for(i=(0);i<(N);i++){
      int k;
      for(k=(0);k<(5);k++){
        nx[k] = dp[k];
      }
      for(k=(0);k<(4);k++){
        chmax(nx[k+1], dp[k] + (long long)a[k] * b[i]);
      }
      for(k=(0);k<(5);k++){
        dp[k] = nx[k];
      }
    }
    return dp[4];
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   long long maxScore(vector<int>& a, vector<int>& b) {
//     int N = b.size();
//     ll dp[5], nx[5];
// 
//     rep(i,5) dp[i] = -ll_inf;
//     dp[0] = 0;
// 
//     rep(i,N){
//       rep(k,5) nx[k] = dp[k];
//       rep(k,4) nx[k+1] >?= dp[k] + (ll)a[k] * b[i];
//       rep(k,5) dp[k] = nx[k];
//     }
// 
//     return dp[4];
//   }
// };
",1390492414
LayCurse,LayCurse,19,3557,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
struct Rand{
  unsigned x;
  unsigned y;
  unsigned z;
  unsigned w;
  Rand(void){
    x=123456789;
    y=362436069;
    z=521288629;
    w=(unsigned)time(NULL);
  }
  Rand(unsigned seed){
    x=123456789;
    y=362436069;
    z=521288629;
    w=seed;
  }
  inline unsigned get(void){
    unsigned t;
    t = (x^(x<<11));
    x=y;
    y=z;
    z=w;
    w = (w^(w>>19))^(t^(t>>8));
    return w;
  }
  inline double getUni(void){
    return get()/4294967296.0;
  }
  inline int get(int a){
    return (int)(a*getUni());
  }
  inline int get(int a, int b){
    return a+(int)((b-a+1)*getUni());
  }
  inline long long get(long long a){
    return(long long)(a*getUni());
  }
  inline long long get(long long a, long long b){
    return a+(long long)((b-a+1)*getUni());
  }
  inline double get(double a, double b){
    return a+(b-a)*getUni();
  }
  inline int getExp(int a){
    return(int)(exp(getUni()*log(a+1.0))-1.0);
  }
  inline int getExp(int a, int b){
    return a+(int)(exp(getUni()*log((b-a+1)+1.0))-1.0);
  }
}
;
template<class T, class U> inline T GCD_L(T a, U b){
  T r;
  while(b){
    r=a;
    a=b;
    b=r%a;
  }
  return a;
}
#define ROLLING_HASH_MOD (2305843009213693951ULL)
#define ROLLING_HASH_PRIMITIVE_ROOT (3)
#define ROLLING_HASH_MAX_MEMORY (2000000)
int ROLLING_HASH_MEM;
unsigned long long ROLLING_HASH_BASE;
unsigned long long ROLLING_HASH_IBASE;
unsigned long long*ROLLING_HASH_PW = NULL;
unsigned long long*ROLLING_HASH_IPW = NULL;
inline unsigned long long rollingHash61_mul(unsigned long long a, unsigned long long b){
  __uint128_t r = (__uint128_t) a * b;
  a = (r >> 61) + (r & ROLLING_HASH_MOD);
  if(a >= ROLLING_HASH_MOD){
    a -= ROLLING_HASH_MOD;
  }
  return a;
}
inline unsigned long long rollingHash61_pow(unsigned long long a, unsigned long long b){
  unsigned long long r = 1;
  for(;;){
    if(b&1){
      r = rollingHash61_mul(r, a);
    }
    if(b==0){
      break;
    }
    b >>= 1;
    a = rollingHash61_mul(a, a);
  }
  return r;
}
void rollingHashInit(){
  int i;
  Rand rnd;
  unsigned long long x;
  for(i=(0);i<(20);i++){
    rnd.get(2);
  }
  do{
    x = rnd.get(1.0, (double)(ROLLING_HASH_MOD-2));
  }
  while(GCD_L(x, ROLLING_HASH_MOD-1)!= 1);
  ROLLING_HASH_BASE = rollingHash61_pow(ROLLING_HASH_PRIMITIVE_ROOT, x);
  ROLLING_HASH_IBASE = rollingHash61_pow(ROLLING_HASH_BASE, ROLLING_HASH_MOD - 2);
}
void rollingHash_expand(int k){
  int i;
  if(ROLLING_HASH_MEM >= k){
    return;
  }
  ROLLING_HASH_MEM =max_L(2 * ROLLING_HASH_MEM, k);
  assert(ROLLING_HASH_MEM <= 2 * ROLLING_HASH_MAX_MEMORY);
  ROLLING_HASH_PW = (unsigned long long*) realloc(ROLLING_HASH_PW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_IPW = (unsigned long long*) realloc(ROLLING_HASH_IPW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_PW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_PW[i] = rollingHash61_mul(ROLLING_HASH_PW[i-1], ROLLING_HASH_BASE);
  }
  ROLLING_HASH_IPW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_IPW[i] = rollingHash61_mul(ROLLING_HASH_IPW[i-1], ROLLING_HASH_IBASE);
  }
}
struct rollingHash{
  long long len;
  unsigned long long hs;
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    hs = 0;
    len = N;
    rollingHash_expand(N);
    for(i=(0);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs += rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs >= ROLLING_HASH_MOD){
        hs -= ROLLING_HASH_MOD;
      }
    }
  }
  template<class S, class T> void change(long long ind, S bef, T aft){
    long long tmp1;
    long long tmp2;
    tmp1 = bef % ((long long)ROLLING_HASH_MOD);
    tmp2 = aft % ((long long)ROLLING_HASH_MOD);
    tmp1 = tmp2 - tmp1;
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 >= ROLLING_HASH_MOD){
      tmp1 -= ROLLING_HASH_MOD;
    }
    if(ind+1 <= ROLLING_HASH_MAX_MEMORY || ind+1 >= ROLLING_HASH_MEM){
      rollingHash_expand(ind+1);
      hs += rollingHash61_mul(tmp1, ROLLING_HASH_PW[ind]);
    }
    else{
      hs += rollingHash61_mul(tmp1, rollingHash61_pow(ROLLING_HASH_BASE, ind));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
  }
  void push_front(rollingHash a){
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_PW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_BASE, a.len));
    }
    hs += a.hs;
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void push_back(rollingHash a){
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      hs += rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      hs += rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void pop_front(rollingHash a){
    if(hs >= a.hs){
      hs -= a.hs;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - a.hs;
    }
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_IPW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_IBASE, a.len));
    }
    len -= a.len;
  }
  void pop_back(rollingHash a){
    unsigned long long tmp;
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      tmp = rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      tmp = rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= tmp){
      hs -= tmp;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - tmp;
    }
    len -= a.len;
  }
  bool operator==(const rollingHash a){
    return len == a.len && hs == a.hs;
  }
  bool operator!=(const rollingHash a){
    return len != a.len || hs != a.hs;
  }
}
;
template<class T> rollingHash calcRollingHash(int N, T A[]){
  rollingHash res;
  res.set(N, A);
  return res;
}
struct rollingHashSubarrays{
  unsigned long long*hs;
  int mem;
  int len;
  void set(){
    hs = NULL;
    mem = len = 0;
  }
  void free(){
    if(mem){
      delete[] hs;
    }
  }
  void expand(int k){
    if(mem >= k){
      return;
    }
    free();
    mem =max_L(2*mem, k);
    hs = new unsigned long long[mem];
  }
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    if(N <= 0){
      return;
    }
    rollingHash_expand(N);
    expand(N);
    len = N;
    tmp = A[0] % ((long long)ROLLING_HASH_MOD);
    if(tmp < 0){
      tmp += ROLLING_HASH_MOD;
    }
    hs[0] = tmp;
    for(i=(1);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs[i] = hs[i-1] + rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs[i] >= ROLLING_HASH_MOD){
        hs[i] -= ROLLING_HASH_MOD;
      }
    }
  }
  rollingHash get_len(int s, int len){
    unsigned long long x;
    rollingHash res;
    res.len = len;
    rollingHash_expand(s+1);
    if(s == 0){
      res.hs = hs[len-1];
    }
    else{
      if(hs[s+len-1] >= hs[s-1]){
        res.hs = hs[s+len-1] - hs[s-1];
      }
      else{
        res.hs = hs[s+len-1] + ROLLING_HASH_MOD - hs[s-1];
      }
      res.hs = rollingHash61_mul(res.hs, ROLLING_HASH_IPW[s]);
    }
    return res;
  }
  rollingHash get(int a, int b){
    return get_len(a, b - a + 1);
  }
  rollingHashSubarrays(){
    set();
  }
  ~rollingHashSubarrays(){
    free();
  }
}
;
#define main dummy_main
int main(){
  {
    rollingHashInit();
  }
  return 0;
}
#undef main
class Solution{
  public:
  int minValidStrings(vector<string>& words, string t){
    dummy_main();
    int i;
    int j;
    int k;
    int N;
    static int dp[1000000];
    static int ds;
    set<unsigned long long> hs;
    rollingHashSubarrays arr;
    for(string s : words){
      arr.set(s.size(), s.c_str());
      for(i=(0);i<(s.size());i++){
        hs.insert( arr.get_len(0,i+1).hs );
      }
    }
    N = t.size();
    for(i=(0);i<(N+1);i++){
      dp[i] = 1073709056;
    }
    dp[0] = 0;
    ds = 1;
    arr.set(N, t.c_str());
    for(i=(0);i<(N);i++){
      if(dp[i] < 1073709056){
        int OA9NF42T;
        int ATMZloZo;
        int pyHJGNQc;
        OA9NF42T = 0;
        ATMZloZo = N-i;
        while(OA9NF42T < ATMZloZo){
          if((OA9NF42T + ATMZloZo)%2==0){
            pyHJGNQc = (OA9NF42T + ATMZloZo) / 2;
          }
          else{
            pyHJGNQc = (OA9NF42T + ATMZloZo + 1) / 2;
          }
          if( hs.count(arr.get_len(i,pyHJGNQc).hs) ){
            OA9NF42T = pyHJGNQc;
          }
          else{
            ATMZloZo = pyHJGNQc - 1;
          }
        }
        k =ATMZloZo;
        while(ds <= i+k){
          dp[ds++] = dp[i] + 1;
        }
      }
    }
    if(dp[N] == 1073709056){
      dp[N] = -1;
    }
    return dp[N];
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int minValidStrings(vector<string>& words, string t) {
//     dummy_main();
// 
//     int i, j, k, N;
//     static int dp[1d6], ds;
//     set<ull> hs;
//     rollingHashSubarrays arr;
// 
//     for(string s : words){
//       arr.set(s.size(), s.c_str());
//       rep(i,s.size()) hs.insert( arr.get_len(0,i+1).hs );
//     }
// 
//     N = t.size();
//     rep(i,N+1) dp[i] = int_inf;
//     dp[0] = 0;
//     ds = 1;
// 
//     arr.set(N, t.c_str());
//     rep(i,N) if(dp[i] < int_inf) {
//       k = bsearch_max[int,k,0,N-i]( hs.count(arr.get_len(i,k).hs) );
//       while(ds <= i+k) dp[ds++] = dp[i] + 1;
//     }
// 
//     if(dp[N] == int_inf) dp[N] = -1;
//     return dp[N];
//   }
// };
",1390513737
LayCurse,LayCurse,19,3559,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
struct Rand{
  unsigned x;
  unsigned y;
  unsigned z;
  unsigned w;
  Rand(void){
    x=123456789;
    y=362436069;
    z=521288629;
    w=(unsigned)time(NULL);
  }
  Rand(unsigned seed){
    x=123456789;
    y=362436069;
    z=521288629;
    w=seed;
  }
  inline unsigned get(void){
    unsigned t;
    t = (x^(x<<11));
    x=y;
    y=z;
    z=w;
    w = (w^(w>>19))^(t^(t>>8));
    return w;
  }
  inline double getUni(void){
    return get()/4294967296.0;
  }
  inline int get(int a){
    return (int)(a*getUni());
  }
  inline int get(int a, int b){
    return a+(int)((b-a+1)*getUni());
  }
  inline long long get(long long a){
    return(long long)(a*getUni());
  }
  inline long long get(long long a, long long b){
    return a+(long long)((b-a+1)*getUni());
  }
  inline double get(double a, double b){
    return a+(b-a)*getUni();
  }
  inline int getExp(int a){
    return(int)(exp(getUni()*log(a+1.0))-1.0);
  }
  inline int getExp(int a, int b){
    return a+(int)(exp(getUni()*log((b-a+1)+1.0))-1.0);
  }
}
;
template<class T, class U> inline T GCD_L(T a, U b){
  T r;
  while(b){
    r=a;
    a=b;
    b=r%a;
  }
  return a;
}
#define ROLLING_HASH_MOD (2305843009213693951ULL)
#define ROLLING_HASH_PRIMITIVE_ROOT (3)
#define ROLLING_HASH_MAX_MEMORY (2000000)
int ROLLING_HASH_MEM;
unsigned long long ROLLING_HASH_BASE;
unsigned long long ROLLING_HASH_IBASE;
unsigned long long*ROLLING_HASH_PW = NULL;
unsigned long long*ROLLING_HASH_IPW = NULL;
inline unsigned long long rollingHash61_mul(unsigned long long a, unsigned long long b){
  __uint128_t r = (__uint128_t) a * b;
  a = (r >> 61) + (r & ROLLING_HASH_MOD);
  if(a >= ROLLING_HASH_MOD){
    a -= ROLLING_HASH_MOD;
  }
  return a;
}
inline unsigned long long rollingHash61_pow(unsigned long long a, unsigned long long b){
  unsigned long long r = 1;
  for(;;){
    if(b&1){
      r = rollingHash61_mul(r, a);
    }
    if(b==0){
      break;
    }
    b >>= 1;
    a = rollingHash61_mul(a, a);
  }
  return r;
}
void rollingHashInit(){
  int i;
  Rand rnd;
  unsigned long long x;
  for(i=(0);i<(20);i++){
    rnd.get(2);
  }
  do{
    x = rnd.get(1.0, (double)(ROLLING_HASH_MOD-2));
  }
  while(GCD_L(x, ROLLING_HASH_MOD-1)!= 1);
  ROLLING_HASH_BASE = rollingHash61_pow(ROLLING_HASH_PRIMITIVE_ROOT, x);
  ROLLING_HASH_IBASE = rollingHash61_pow(ROLLING_HASH_BASE, ROLLING_HASH_MOD - 2);
}
void rollingHash_expand(int k){
  int i;
  if(ROLLING_HASH_MEM >= k){
    return;
  }
  ROLLING_HASH_MEM =max_L(2 * ROLLING_HASH_MEM, k);
  assert(ROLLING_HASH_MEM <= 2 * ROLLING_HASH_MAX_MEMORY);
  ROLLING_HASH_PW = (unsigned long long*) realloc(ROLLING_HASH_PW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_IPW = (unsigned long long*) realloc(ROLLING_HASH_IPW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_PW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_PW[i] = rollingHash61_mul(ROLLING_HASH_PW[i-1], ROLLING_HASH_BASE);
  }
  ROLLING_HASH_IPW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_IPW[i] = rollingHash61_mul(ROLLING_HASH_IPW[i-1], ROLLING_HASH_IBASE);
  }
}
struct rollingHash{
  long long len;
  unsigned long long hs;
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    hs = 0;
    len = N;
    rollingHash_expand(N);
    for(i=(0);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs += rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs >= ROLLING_HASH_MOD){
        hs -= ROLLING_HASH_MOD;
      }
    }
  }
  template<class S, class T> void change(long long ind, S bef, T aft){
    long long tmp1;
    long long tmp2;
    tmp1 = bef % ((long long)ROLLING_HASH_MOD);
    tmp2 = aft % ((long long)ROLLING_HASH_MOD);
    tmp1 = tmp2 - tmp1;
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 >= ROLLING_HASH_MOD){
      tmp1 -= ROLLING_HASH_MOD;
    }
    if(ind+1 <= ROLLING_HASH_MAX_MEMORY || ind+1 >= ROLLING_HASH_MEM){
      rollingHash_expand(ind+1);
      hs += rollingHash61_mul(tmp1, ROLLING_HASH_PW[ind]);
    }
    else{
      hs += rollingHash61_mul(tmp1, rollingHash61_pow(ROLLING_HASH_BASE, ind));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
  }
  void push_front(rollingHash a){
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_PW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_BASE, a.len));
    }
    hs += a.hs;
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void push_back(rollingHash a){
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      hs += rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      hs += rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void pop_front(rollingHash a){
    if(hs >= a.hs){
      hs -= a.hs;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - a.hs;
    }
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_IPW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_IBASE, a.len));
    }
    len -= a.len;
  }
  void pop_back(rollingHash a){
    unsigned long long tmp;
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      tmp = rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      tmp = rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= tmp){
      hs -= tmp;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - tmp;
    }
    len -= a.len;
  }
  bool operator==(const rollingHash a){
    return len == a.len && hs == a.hs;
  }
  bool operator!=(const rollingHash a){
    return len != a.len || hs != a.hs;
  }
}
;
template<class T> rollingHash calcRollingHash(int N, T A[]){
  rollingHash res;
  res.set(N, A);
  return res;
}
struct rollingHashSubarrays{
  unsigned long long*hs;
  int mem;
  int len;
  void set(){
    hs = NULL;
    mem = len = 0;
  }
  void free(){
    if(mem){
      delete[] hs;
    }
  }
  void expand(int k){
    if(mem >= k){
      return;
    }
    free();
    mem =max_L(2*mem, k);
    hs = new unsigned long long[mem];
  }
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    if(N <= 0){
      return;
    }
    rollingHash_expand(N);
    expand(N);
    len = N;
    tmp = A[0] % ((long long)ROLLING_HASH_MOD);
    if(tmp < 0){
      tmp += ROLLING_HASH_MOD;
    }
    hs[0] = tmp;
    for(i=(1);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs[i] = hs[i-1] + rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs[i] >= ROLLING_HASH_MOD){
        hs[i] -= ROLLING_HASH_MOD;
      }
    }
  }
  rollingHash get_len(int s, int len){
    unsigned long long x;
    rollingHash res;
    res.len = len;
    rollingHash_expand(s+1);
    if(s == 0){
      res.hs = hs[len-1];
    }
    else{
      if(hs[s+len-1] >= hs[s-1]){
        res.hs = hs[s+len-1] - hs[s-1];
      }
      else{
        res.hs = hs[s+len-1] + ROLLING_HASH_MOD - hs[s-1];
      }
      res.hs = rollingHash61_mul(res.hs, ROLLING_HASH_IPW[s]);
    }
    return res;
  }
  rollingHash get(int a, int b){
    return get_len(a, b - a + 1);
  }
  rollingHashSubarrays(){
    set();
  }
  ~rollingHashSubarrays(){
    free();
  }
}
;
#define main dummy_main
int main(){
  {
    rollingHashInit();
  }
  return 0;
}
#undef main
class Solution{
  public:
  int minValidStrings(vector<string>& words, string t){
    dummy_main();
    int i;
    int j;
    int k;
    int N;
    static int dp[1000000];
    static int ds;
    set<unsigned long long> hs;
    rollingHashSubarrays arr;
    for(string s : words){
      arr.set(s.size(), s.c_str());
      for(i=(0);i<(s.size());i++){
        hs.insert( arr.get_len(0,i+1).hs );
      }
    }
    N = t.size();
    for(i=(0);i<(N+1);i++){
      dp[i] = 1073709056;
    }
    dp[0] = 0;
    ds = 1;
    arr.set(N, t.c_str());
    for(i=(0);i<(N);i++){
      if(dp[i] < 1073709056){
        int OA9NF42T;
        int ATMZloZo;
        int pyHJGNQc;
        OA9NF42T = 0;
        ATMZloZo = N-i;
        while(OA9NF42T < ATMZloZo){
          if((OA9NF42T + ATMZloZo)%2==0){
            pyHJGNQc = (OA9NF42T + ATMZloZo) / 2;
          }
          else{
            pyHJGNQc = (OA9NF42T + ATMZloZo + 1) / 2;
          }
          if( hs.count(arr.get_len(i,pyHJGNQc).hs) ){
            OA9NF42T = pyHJGNQc;
          }
          else{
            ATMZloZo = pyHJGNQc - 1;
          }
        }
        k =ATMZloZo;
        while(ds <= i+k){
          dp[ds++] = dp[i] + 1;
        }
      }
    }
    if(dp[N] == 1073709056){
      dp[N] = -1;
    }
    return dp[N];
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int minValidStrings(vector<string>& words, string t) {
//     dummy_main();
// 
//     int i, j, k, N;
//     static int dp[1d6], ds;
//     set<ull> hs;
//     rollingHashSubarrays arr;
// 
//     for(string s : words){
//       arr.set(s.size(), s.c_str());
//       rep(i,s.size()) hs.insert( arr.get_len(0,i+1).hs );
//     }
// 
//     N = t.size();
//     rep(i,N+1) dp[i] = int_inf;
//     dp[0] = 0;
//     ds = 1;
// 
//     arr.set(N, t.c_str());
//     rep(i,N) if(dp[i] < int_inf) {
//       k = bsearch_max[int,k,0,N-i]( hs.count(arr.get_len(i,k).hs) );
//       while(ds <= i+k) dp[ds++] = dp[i] + 1;
//     }
// 
//     if(dp[N] == int_inf) dp[N] = -1;
//     return dp[N];
//   }
// };
",1390513474
LayCurse,LayCurse,19,3581,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  vector<int> getSneakyNumbers(vector<int>& A){
    int i;
    int N = A.size();
    static int h[1000000];
    vector<int> res;
    for(i=(0);i<(N+1);i++){
      h[i] = 0;
    }
    for(i=(0);i<(N);i++){
      h[A[i]]++;
    }
    for(i=(0);i<(N+1);i++){
      if(h[i]==2){
        res.push_back(i);
      }
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   vector<int> getSneakyNumbers(vector<int>& A) {
//     int N = A.size();
//     static int h[1d6];
//     VI res;
//     rep(i,N+1) h[i] = 0;
//     rep(i,N) h[A[i]]++;
//     rep(i,N+1) if(h[i]==2) res.push_back(i);
//     return res;
//   }
// };
",1390489188
Yiming Li,lympanda,20,3518,cpp,"#define _int64 long long

_int64 d[110000][5];

class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int i,j,k,n;
        _int64 tmp;
        n=b.size();
        for (i=0;i<5;i++)
            d[0][i]=-(1LL<<60);
        d[0][0]=0;
        for (i=0;i<n;i++)
        {
            for (j=0;j<5;j++)
                d[i+1][j]=d[i][j];
            for (j=0;j<4;j++)
            {
                if (d[i][j]==-(1LL<<60)) continue;
                tmp=d[i][j]+(_int64)a[j]*b[i];
                d[i+1][j+1]=max(d[i+1][j+1],tmp);
            }
        }
        return d[n][4];
    }
};",1390489404
Yiming Li,lympanda,20,3557,cpp,"#define _int64 long long

std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
int mo = rng() % 1000000000 + 123456;


template <typename T>
struct binary_indexed_tree{
  int N;
  vector<T> BIT;
  binary_indexed_tree(int N): N(N), BIT(N + 1, (1<<30)){
  }
  void add(int i, T x){
    while (i <= N){
      BIT[i] = min(BIT[i],x);
      i += i & -i;
    }
  }
  T get(int i){
    T ans = (1<<30);
    while (i > 0){
      ans = min(ans,BIT[i]);
      i -= i & -i;
    }
    return ans;
  }
  T get(int L, int R){
    return get(R) - get(L-1);
  }
};

_int64 pow1[51000];
_int64 ha[51000];
_int64 ha1[510000];
int d[51000];

_int64 geth(int x,int y)
{
    _int64 ret;
    ret=ha[x+y]-ha[x]*pow1[y];
    ret%=mo;
    if (ret<0) ret+=mo;
    return ret;
}

_int64 geth1(int x,int y)
{
    _int64 ret;
    ret=ha1[x+y]-ha1[x]*pow1[y];
    ret%=mo;
    if (ret<0) ret+=mo;
    return ret;

}

class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int i,j,k,n,ll,rr,mid,x;
        _int64 v1,v2;
        n=target.length();
        pow1[0]=1;
        for (i=1;i<51000;i++)
            pow1[i]=pow1[i-1]*27%mo;
        ha[0]=0;
        for (i=0;i<n;i++)
        {
            ha[i+1]=ha[i]*27+target[i]-'a'+1;
            ha[i+1]%=mo;
        }
        for (i=0;i<=n;i++)
            d[i]=0;
        for (i=0;i<words.size();i++)
        {
            ha1[0]=0;
            for (j=0;j<words[i].length();j++)
            {
                ha1[j+1]=ha1[j]*27+words[i][j]-'a'+1;
                ha1[j+1]%=mo;
            }
            for (j=0;j<n;j++)
            {
                ll=0;rr=min(n-j,(int)words[i].length())+1;
                while (rr-ll>1)
                {
                    mid=(ll+rr)/2;
                    v1=geth(j,mid);
                    v2=geth1(0,mid);
                    if (v1==v2) ll=mid;
                    else rr=mid;
                }
                d[j]=max(d[j],ll);
            }
        }
        binary_indexed_tree<int> bit(n+10);
        d[n]=0;
        bit.add(n+1,0);
        for (i=n-1;i>=0;i--)
        {
            x=i+d[i];
            d[i]=bit.get(x+1);
            if (d[i]!=(1<<30)) d[i]++;
            bit.add(i+1,d[i]);
        }
        if (d[0]==(1<<30)) return -1;
        return d[0];
    }
};",1390523349
Yiming Li,lympanda,20,3559,cpp,"#define _int64 long long

std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
int mo = rng() % 1000000000 + 123456;


template <typename T>
struct binary_indexed_tree{
  int N;
  vector<T> BIT;
  binary_indexed_tree(int N): N(N), BIT(N + 1, (1<<30)){
  }
  void add(int i, T x){
    while (i <= N){
      BIT[i] = min(BIT[i],x);
      i += i & -i;
    }
  }
  T get(int i){
    T ans = (1<<30);
    while (i > 0){
      ans = min(ans,BIT[i]);
      i -= i & -i;
    }
    return ans;
  }
  T get(int L, int R){
    return get(R) - get(L-1);
  }
};

_int64 pow1[51000];
_int64 ha[51000];
_int64 ha1[510000];
int d[51000];

_int64 geth(int x,int y)
{
    _int64 ret;
    ret=ha[x+y]-ha[x]*pow1[y];
    ret%=mo;
    if (ret<0) ret+=mo;
    return ret;
}

_int64 geth1(int x,int y)
{
    _int64 ret;
    ret=ha1[x+y]-ha1[x]*pow1[y];
    ret%=mo;
    if (ret<0) ret+=mo;
    return ret;

}

class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int i,j,k,n,ll,rr,mid,x;
        _int64 v1,v2;
        n=target.length();
        pow1[0]=1;
        for (i=1;i<51000;i++)
            pow1[i]=pow1[i-1]*27%mo;
        ha[0]=0;
        for (i=0;i<n;i++)
        {
            ha[i+1]=ha[i]*27+target[i]-'a'+1;
            ha[i+1]%=mo;
        }
        for (i=0;i<=n;i++)
            d[i]=0;
        for (i=0;i<words.size();i++)
        {
            ha1[0]=0;
            for (j=0;j<words[i].length();j++)
            {
                ha1[j+1]=ha1[j]*27+words[i][j]-'a'+1;
                ha1[j+1]%=mo;
            }
            for (j=0;j<n;j++)
            {
                ll=0;rr=min(n-j,(int)words[i].length())+1;
                while (rr-ll>1)
                {
                    mid=(ll+rr)/2;
                    v1=geth(j,mid);
                    v2=geth1(0,mid);
                    if (v1==v2) ll=mid;
                    else rr=mid;
                }
                d[j]=max(d[j],ll);
            }
        }
        binary_indexed_tree<int> bit(n+10);
        d[n]=0;
        bit.add(n+1,0);
        for (i=n-1;i>=0;i--)
        {
            x=i+d[i];
            d[i]=bit.get(x+1);
            if (d[i]!=(1<<30)) d[i]++;
            bit.add(i+1,d[i]);
        }
        if (d[0]==(1<<30)) return -1;
        return d[0];
    }
};",1390523577
Yiming Li,lympanda,20,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& a) {
        int i,j,n;
        n=a.size()-2;
        vector<int> cnt=vector<int>(n,0);
        vector<int> ans;
        ans.clear();
        for (i=0;i<a.size();i++)
        {
            if (cnt[a[i]]==1) ans.push_back(a[i]);
            else cnt[a[i]]++;
        }
        return ans;
    }
};",1390480510
Plasmatic,plasmatic,22,3518,cpp,"using ll = long long;

const ll INF = 0x3f3f3f3f, LLINF = 0x3f3f3f3f3f3f3f3f;

class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        vector<vector<ll>> dp(n+1, vector<ll>(5, -LLINF));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 4; j++) {
                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + (ll)(a[j]) * (ll)(b[i]));
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            }
            dp[i+1][4] = max(dp[i+1][4], dp[i][4]);
        }
        return dp[n][4];
    }
};",1390491035
Plasmatic,plasmatic,22,3557,cpp,"#include <bits/stdc++.h>
#define DEBUG 1
using namespace std;

// Defines
#define fs first
#define sn second
#define pb push_back
#define eb emplace_back
#define mpr make_pair
#define mtp make_tuple
#define all(x) (x).begin(), (x).end()
// Basic type definitions
#if __cplusplus == 201703L // CPP17 only things
template <typename T> using opt_ref = optional<reference_wrapper<T>>; // for some templates
#endif
using ll = long long; using ull = unsigned long long; using ld = long double;
using pii = pair<int, int>; using pll = pair<long long, long long>;
#ifdef __GNUG__
// PBDS order statistic tree
#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template <typename T, class comp = less<T>> using os_tree = tree<T, null_type, comp, rb_tree_tag, tree_order_statistics_node_update>;
template <typename K, typename V, class comp = less<K>> using treemap = tree<K, V, comp, rb_tree_tag, tree_order_statistics_node_update>;
// HashSet
#include <ext/pb_ds/assoc_container.hpp>
template <typename T, class Hash> using hashset = gp_hash_table<T, null_type, Hash>;
template <typename K, typename V, class Hash> using hashmap = gp_hash_table<K, V, Hash>;
const ll RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();
struct chash { ll operator()(ll x) const { return x ^ RANDOM; } };
#endif
// More utilities
int SZ(string &v) { return v.length(); }
template <typename C> int SZ(C &v) { return v.size(); }
template <typename C> void UNIQUE(vector<C> &v) { sort(v.begin(), v.end()); v.resize(unique(v.begin(), v.end()) - v.begin()); }
template <typename T, typename U> void maxa(T &a, U b) { a = max(a, b); }
template <typename T, typename U> void mina(T &a, U b) { a = min(a, b); }
const ll INF = 0x3f3f3f3f, LLINF = 0x3f3f3f3f3f3f3f3f;

// Hashing stuff
const int FIXED_BASE = 0, RAND_BASE = 1 << 0;
const ll MOD = 999999999999999989;
ll BASE = 131;

vector<ll> _hash_pows;
template <int MODE> void init_hash(int MAX_N) {
    if (MODE & RAND_BASE) {
        mt19937 mt(RANDOM);
        BASE = uniform_int_distribution<ll>(MOD/2, MOD-2)(mt);
    }

    _hash_pows.resize(MAX_N + 1);
    _hash_pows[0] = 1LL;
    for (auto i = 1; i <= MAX_N; i++)
        _hash_pows[i] = __int128(_hash_pows[i - 1]) * BASE % MOD;
}
template <typename It> ll hget(It hs, int l, int r) {
    __int128 res = (hs[r] - __int128(hs[l - 1]) * _hash_pows[r - l + 1]) % MOD;
    if (res < 0) res += MOD;
    return res;
}
ll happend(ll hsh, int val) { return (__int128(hsh) * BASE + val) % MOD; }
ll hconcat(ll hshLeft, ll hshRight, int szRight) { return (__int128(hshLeft) * _hash_pows[szRight] + hshRight) % MOD; }

class Solution {
    bool initHashDone = false;

    vector<ll> getHash(const string &s) {
        vector<ll> hashes(s.length() + 1);
        for (int i = 0; i < s.length(); i++) {
            hashes[i+1] = happend(hashes[i], s[i]);
        }
        return hashes;
    }

public:
    int minValidStrings(vector<string>& words, string target) {
        if (!initHashDone) {
            initHashDone = true;
            init_hash<FIXED_BASE>(100000 + 10);
        }

        int n = words.size();
        int t = target.size();
        vector<vector<ll>> wordsHash(n);
        vector<ll> targetHash = getHash(target);
        for (int i = 0; i < n; i++)
            wordsHash[i] = getHash(words[i]);

        unordered_set<ll> validHashes;
        for (auto &wordHash : wordsHash)
            for (auto &hValue : wordHash)
                validHashes.insert(hValue);
        
        vector<int> dp(t+1, INF);
        dp[0] = 0;
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        for (int i = 0; i < t; i++) {
            // expand from DP[i]
            int l = i, r = t, furthest = -1;
            while (l <= r) {
                int mid = (l + r) / 2;

                ll cHash = hget(targetHash.data(), i+1, mid);
                if (validHashes.count(cHash)) {
                    furthest = mid;
                    l = mid + 1;
                }
                else {
                    r = mid - 1;
                }
            }

            pq.emplace(dp[i], furthest);

            // Use to calculate dp[i+1]
            while (!pq.empty() && pq.top().sn < i+1) {
                pq.pop();
            }
            if (!pq.empty()) {
                dp[i+1] = pq.top().fs + 1;
            }
        }

        int ans = dp[t] >= INF ? -1 : dp[t];
        return ans;
    }
};",1390517331
Plasmatic,plasmatic,22,3559,cpp,"#include <bits/stdc++.h>
#define DEBUG 1
using namespace std;

// Defines
#define fs first
#define sn second
#define pb push_back
#define eb emplace_back
#define mpr make_pair
#define mtp make_tuple
#define all(x) (x).begin(), (x).end()
// Basic type definitions
#if __cplusplus == 201703L // CPP17 only things
template <typename T> using opt_ref = optional<reference_wrapper<T>>; // for some templates
#endif
using ll = long long; using ull = unsigned long long; using ld = long double;
using pii = pair<int, int>; using pll = pair<long long, long long>;
#ifdef __GNUG__
// PBDS order statistic tree
#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template <typename T, class comp = less<T>> using os_tree = tree<T, null_type, comp, rb_tree_tag, tree_order_statistics_node_update>;
template <typename K, typename V, class comp = less<K>> using treemap = tree<K, V, comp, rb_tree_tag, tree_order_statistics_node_update>;
// HashSet
#include <ext/pb_ds/assoc_container.hpp>
template <typename T, class Hash> using hashset = gp_hash_table<T, null_type, Hash>;
template <typename K, typename V, class Hash> using hashmap = gp_hash_table<K, V, Hash>;
const ll RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();
struct chash { ll operator()(ll x) const { return x ^ RANDOM; } };
#endif
// More utilities
int SZ(string &v) { return v.length(); }
template <typename C> int SZ(C &v) { return v.size(); }
template <typename C> void UNIQUE(vector<C> &v) { sort(v.begin(), v.end()); v.resize(unique(v.begin(), v.end()) - v.begin()); }
template <typename T, typename U> void maxa(T &a, U b) { a = max(a, b); }
template <typename T, typename U> void mina(T &a, U b) { a = min(a, b); }
const ll INF = 0x3f3f3f3f, LLINF = 0x3f3f3f3f3f3f3f3f;

// Hashing stuff
const int FIXED_BASE = 0, RAND_BASE = 1 << 0;
const ll MOD = 999999999999999989;
ll BASE = 131;

vector<ll> _hash_pows;
template <int MODE> void init_hash(int MAX_N) {
    if (MODE & RAND_BASE) {
        mt19937 mt(RANDOM);
        BASE = uniform_int_distribution<ll>(MOD/2, MOD-2)(mt);
    }

    _hash_pows.resize(MAX_N + 1);
    _hash_pows[0] = 1LL;
    for (auto i = 1; i <= MAX_N; i++)
        _hash_pows[i] = __int128(_hash_pows[i - 1]) * BASE % MOD;
}
template <typename It> ll hget(It hs, int l, int r) {
    __int128 res = (hs[r] - __int128(hs[l - 1]) * _hash_pows[r - l + 1]) % MOD;
    if (res < 0) res += MOD;
    return res;
}
ll happend(ll hsh, int val) { return (__int128(hsh) * BASE + val) % MOD; }
ll hconcat(ll hshLeft, ll hshRight, int szRight) { return (__int128(hshLeft) * _hash_pows[szRight] + hshRight) % MOD; }

class Solution {
    bool initHashDone = false;

    vector<ll> getHash(const string &s) {
        vector<ll> hashes(s.length() + 1);
        for (int i = 0; i < s.length(); i++) {
            hashes[i+1] = happend(hashes[i], s[i]);
        }
        return hashes;
    }

public:
    int minValidStrings(vector<string>& words, string target) {
        if (!initHashDone) {
            initHashDone = true;
            init_hash<FIXED_BASE>(100000 + 10);
        }

        int n = words.size();
        int t = target.size();
        vector<vector<ll>> wordsHash(n);
        vector<ll> targetHash = getHash(target);
        for (int i = 0; i < n; i++)
            wordsHash[i] = getHash(words[i]);

        unordered_set<ll> validHashes;
        for (auto &wordHash : wordsHash)
            for (auto &hValue : wordHash)
                validHashes.insert(hValue);
        
        vector<int> dp(t+1, INF);
        dp[0] = 0;
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        for (int i = 0; i < t; i++) {
            // expand from DP[i]
            int l = i, r = t, furthest = -1;
            while (l <= r) {
                int mid = (l + r) / 2;

                ll cHash = hget(targetHash.data(), i+1, mid);
                if (validHashes.count(cHash)) {
                    furthest = mid;
                    l = mid + 1;
                }
                else {
                    r = mid - 1;
                }
            }

            pq.emplace(dp[i], furthest);

            // Use to calculate dp[i+1]
            while (!pq.empty() && pq.top().sn < i+1) {
                pq.pop();
            }
            if (!pq.empty()) {
                dp[i+1] = pq.top().fs + 1;
            }
        }

        int ans = dp[t] >= INF ? -1 : dp[t];
        return ans;
    }
};",1390515200
Plasmatic,plasmatic,22,3581,python3,"from collections import Counter

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        fre = Counter(nums)
        ans = []
        for k, v in fre.items():
            if v > 1:
                ans.append(k)
        return ans",1390477803
E-Ro Nguyen,nero1905,24,3518,cpp,"void Max(long long &a, long long b) {
    a = a > b ? a : b;
}

class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        vector<vector<long long>> dp(5, vector<long long>(1 + b.size(), -1e18));
        for (int j = 0; j <= b.size(); ++j) dp[0][j] = 0;
        for (int i = 1; i < 5; ++i) {
            for (int j = 0; j < b.size(); ++j) {
                Max(dp[i][j + 1], dp[i][j]);
                Max(dp[i][j + 1], dp[i - 1][j] + 1ll * a[i - 1] * b[j]);
            }
        }
        return dp[4][b.size()];
    }
};",1390491008
E-Ro Nguyen,nero1905,24,3557,cpp,"void Min(int&a, int b) { a = a > b ? b : a; }
class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = words.size();
        vector<vector<int>> kmp(n, vector<int>(target.size()));
        vector<int> pi;
        for (int j = 0; j < n; ++j) {
            int m = words[j].size();
            pi.resize(m, 0);
            for (int i = 1; i < m; ++i) {
                int k = pi[i - 1];
                while(k && words[j][i] != words[j][k]) k = pi[k - 1];
                if (words[j][i] == words[j][k]) ++k;
                pi[i] = k;
            }
            int k = 0;
            for (int i = 0; i < target.size(); ++i) {
                while (k && target[i] != words[j][k]) k = pi[k - 1];
                if (target[i] == words[j][k]) ++k;
                kmp[j][i] = k;
                if (k == m) k = pi[k - 1];
            }
        }
        vector<int> dp(target.size() + 1, 1e9);
        dp[0] = 0;
        for (int i = 0; i < target.size(); ++i) {
            for (int j = 0; j < n; ++j) if (kmp[j][i] != 0) {
                Min(dp[i + 1], dp[i + 1 - kmp[j][i]] + 1);
            }
        }
        if (dp[target.size()] == 1e9) return -1;
        return dp[target.size()];
    }
};",1390517551
E-Ro Nguyen,nero1905,24,3559,cpp,"void Min(int&a, int b) { a = a > b ? b : a; }
class Solution {
public:
    int minValidStrings(vector<string>& words, string target) {
        int n = words.size();
        vector<vector<int>> kmp(n, vector<int>(target.size()));
        vector<int> pi;
        for (int j = 0; j < n; ++j) {
            int m = words[j].size();
            pi.resize(m, 0);
            for (int i = 1; i < m; ++i) {
                int k = pi[i - 1];
                while(k && words[j][i] != words[j][k]) k = pi[k - 1];
                if (words[j][i] == words[j][k]) ++k;
                pi[i] = k;
            }
            int k = 0;
            for (int i = 0; i < target.size(); ++i) {
                while (k && target[i] != words[j][k]) k = pi[k - 1];
                if (target[i] == words[j][k]) ++k;
                kmp[j][i] = k;
                if (k == m) k = pi[k - 1];
            }
        }
        vector<int> dp(target.size() + 1, 1e9);
        dp[0] = 0;
        for (int i = 0; i < target.size(); ++i) {
            for (int j = 0; j < n; ++j) if (kmp[j][i] != 0) {
                Min(dp[i + 1], dp[i + 1 - kmp[j][i]] + 1);
            }
        }
        if (dp[target.size()] == 1e9) return -1;
        return dp[target.size()];
    }
};",1390514883
E-Ro Nguyen,nero1905,24,3581,cpp,"class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        vector<int> ans;
        set<int> c;
        for (int x : nums) {
            if (c.find(x) != c.end()) ans.push_back(x);
            else c.insert(x);
        }
        return ans;
    }
};",1390478114
Manan Rathod,Manan04,25,3518,python3,"class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        n = len(b)
        dp = [[-10 ** 18 for i in range(4)] for i in range(n)]
        for i in range(n):
            for j in range(4):
                if(j <= i):
                    dp[i][j] = a[j] * b[i]
                    if(j):
                        dp[i][j] += dp[i - 1][j - 1]
                if(i):
                    dp[i][j] = max(dp[i - 1][j], dp[i][j])
        return dp[-1][3]",1390492401
Manan Rathod,Manan04,25,3557,python3,"class SegmentTree:
    def __init__(self, array, func=max):
        self.n = len(array)
        self.size = 2**(int(log2(self.n-1))+1) if self.n != 1 else 1
        self.func = func
        self.default = 0 if self.func != min else inf
        self.data = [self.default] * (2 * self.size)
        self.process(array)
    def process(self, array):
        self.data[self.size : self.size+self.n] = array
        for i in range(self.size-1, -1, -1):
            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])
    def query(self, alpha, omega):
        if alpha == omega:
            return self.data[alpha + self.size]
        res = self.default
        alpha += self.size
        omega += self.size + 1
        while alpha < omega:
            if alpha & 1:
                res = self.func(res, self.data[alpha])
                alpha += 1
            if omega & 1:
                omega -= 1
                res = self.func(res, self.data[omega])
            alpha >>= 1
            omega >>= 1
        return res
    def update(self, index, value):
        index += self.size
        self.data[index] = value
        index >>= 1
        while index:
            self.data[index] = self.func(self.data[2*index], self.data[2*index+1])
            index >>= 1
import random

HMOD = 2147483647
HBASE1 = random.randrange(HMOD)
HBASE2 = random.randrange(HMOD)


class Hashing:
    def __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):
        self.mod, self.base1, self.base2 = mod, base1, base2
        self._len = _len = len(s)
        f_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)
        s_hash, s_pow = f_hash[:], f_pow[:]
        for i in range(_len):
            f_hash[i + 1] = (base1 * f_hash[i] + ord(s[i])) % mod
            s_hash[i + 1] = (base2 * s_hash[i] + ord(s[i])) % mod
            f_pow[i + 1] = base1 * f_pow[i] % mod
            s_pow[i + 1] = base2 * s_pow[i] % mod
        self.f_hash, self.f_pow = f_hash, f_pow
        self.s_hash, self.s_pow = s_hash, s_pow

    def hashed(self, start, stop):
        return (
            (self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,
            (self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,
        )

    def get_hashes(self, length):
        return (
            [(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in range(self._len - length + 1)],
            [(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in range(self._len - length + 1)],
        )
class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        d = defaultdict(int)
        t = []
        for c in target:
            t.append(c)
        for s in words:
            h = Hashing(s)
            for i in range(len(s)):
                d[h.hashed(0, i + 1)] = 1
        dp = [10 ** 18] * len(t)
        s = SegmentTree(dp, min)
        h = Hashing(t)
        for i in range(len(t) - 1, -1, -1):
            L = i
            U = len(t) - 1
            endd = -1
            while L <= U:
                m = (L + U) >> 1
                if(d[h.hashed(i, m + 1)]):
                    endd = m
                    L = m + 1
                else:
                    U = m - 1
            if(endd == -1):
                continue
            if(endd == len(t) - 1):
                dp[i] = 1
                s.update(i, 1)
                continue
            mn = s.query(i, endd + 1)
            if(mn == 10 ** 18):
                continue
            dp[i] = mn + 1
            s.update(i, mn + 1)
        ans = s.query(0, 0)
        if(ans == 10 ** 18):
            ans = -1
        return ans",1390518105
Manan Rathod,Manan04,25,3559,python3,"class SegmentTree:
    def __init__(self, array, func=max):
        self.n = len(array)
        self.size = 2**(int(log2(self.n-1))+1) if self.n != 1 else 1
        self.func = func
        self.default = 0 if self.func != min else inf
        self.data = [self.default] * (2 * self.size)
        self.process(array)
    def process(self, array):
        self.data[self.size : self.size+self.n] = array
        for i in range(self.size-1, -1, -1):
            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])
    def query(self, alpha, omega):
        if alpha == omega:
            return self.data[alpha + self.size]
        res = self.default
        alpha += self.size
        omega += self.size + 1
        while alpha < omega:
            if alpha & 1:
                res = self.func(res, self.data[alpha])
                alpha += 1
            if omega & 1:
                omega -= 1
                res = self.func(res, self.data[omega])
            alpha >>= 1
            omega >>= 1
        return res
    def update(self, index, value):
        index += self.size
        self.data[index] = value
        index >>= 1
        while index:
            self.data[index] = self.func(self.data[2*index], self.data[2*index+1])
            index >>= 1
class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        d = defaultdict(int)
        t = []
        for c in target:
            t.append(c)
        for s in words:
            helper = []
            for c in s:
                helper.append(c)
                d[hash(tuple(helper))] = 1
        dp = [10 ** 18] * len(t)
        s = SegmentTree(dp, min)
        for i in range(len(t) - 1, -1, -1):
            L = i
            U = len(t) - 1
            endd = -1
            while L <= U:
                m = (L + U) >> 1
                if(d[hash(tuple(t[i: m + 1]))]):
                    endd = m
                    L = m + 1
                else:
                    U = m - 1
            if(endd == -1):
                continue
            if(endd == len(t) - 1):
                dp[i] = 1
                s.update(i, 1)
                continue
            mn = s.query(i, endd + 1)
            if(mn == 10 ** 18):
                continue
            dp[i] = mn + 1
            s.update(i, mn + 1)
        ans = s.query(0, 0)
        if(ans == 10 ** 18):
            ans = -1
        return ans",1390514332
Manan Rathod,Manan04,25,3581,python3,"class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        d = defaultdict(int)
        ans = []
        for val in nums:
            d[val] += 1
            if(d[val] == 2):
                ans.append(val)
        return ans",1390477843
bpnew,bpnew,1,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T):
            total = 0
            for wt in workerTimes:
                S = (2 * T) // wt
                D = 1 + 4 * S
                if D < 0:
                    xi = 0
                else:
                    sqrt_D = int(D**0.5)
                    xi = (-1 + sqrt_D) // 2
                    while (xi + 1) * xi > S:
                        xi -= 1
                    while (xi + 1) * xi <= S:
                        xi += 1
                    xi -=1
                    xi = max(xi, 0)
                total += xi
            return total >= mountainHeight

        left, right = 0, 1 << 60
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left        ",1397971657
bpnew,bpnew,1,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = sum(1 for word in message if word in banned_set)
        return count >= 2        ",1397960528
bpnew,bpnew,1,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        N = len(word1)
        need = [0]*26
        for c in word2:
            need[ord(c)-ord('a')] +=1
        have = [0]*26
        letters_needed = [i for i in range(26) if need[i]>0]
        left = 0
        total = 0
        for right in range(N):
            c = ord(word1[right])-ord('a')
            have[c] +=1
            while all(have[i]>=need[i] for i in letters_needed):
                have[ord(word1[left])-ord('a')] -=1
                left +=1
            total += left
        return total        ",1397967513
bpnew,bpnew,1,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        counts_word2 = defaultdict(int)
        required_letters = set(word2)
        for c in word2:
            counts_word2[c] += 1

        N = len(word1)
        counts = defaultdict(int)
        total_substrings = 0
        left = 0
        right = 0

        while left < N:
            while right < N and any(counts[char] < counts_word2[char] for char in counts_word2):
                counts[word1[right]] +=1
                right +=1
            if any(counts[char] < counts_word2[char] for char in counts_word2):
                break
            total_substrings += N - right +1
            counts[word1[left]] -=1
            left +=1

        return total_substrings        ",1397970226
Konsept,konssept,2,3496,rust,"impl Solution {
    pub fn min_number_of_seconds(mountain_height: i32, worker_times: Vec<i32>) -> i64 {
        let mut low: i64 = 0;
        let mut high: i64 = 1e18 as i64;
        while low < high {
            let mid = low + (high - low) / 2;
            if Self::can_complete(mid, mountain_height, &worker_times) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        low
    }

    fn can_complete(time_limit: i64, mountain_height: i32, worker_times: &Vec<i32>) -> bool {
        let mut total_height_reduced: i64 = 0;
        for &t in worker_times {
            if t == 0 { continue; }
            let D = 1.0 + 8.0 * time_limit as f64 / t as f64;
            if D < 0.0 { continue; }
            let x = ((-1.0 + D.sqrt()) / 2.0) as i64;
            total_height_reduced += x;
            if total_height_reduced >= mountain_height as i64 {
                return true;
            }
        }
        total_height_reduced >= mountain_height as i64
    }
}",1397965114
Konsept,konssept,2,3541,rust,"use std::collections::HashSet;

impl Solution {
    pub fn report_spam(message: Vec<String>, banned_words: Vec<String>) -> bool {
        let banned_set: HashSet<String> = banned_words.into_iter().collect();
        
        let mut count = 0;
        for word in message {
            if banned_set.contains(&word) {
                count += 1;
                if count >= 2 {
                    return true;
                }
            }
        }
        
        false
    }
}",1397960425
Konsept,konssept,2,3572,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397968792
Konsept,konssept,2,3573,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397971736
Yawn_Sean,Yawn_Sean,3,3496,python3,"class Solution:
    def minNumberOfSeconds(self, h: int, ts: List[int]) -> int:
        l, r = 1, 10 ** 18
        while l <= r:
            m = (l + r) // 2
            x = 0
            for t in ts:
                v = m // t
                # (1 + n) * n / 2 <= v
                # 4 * n ^ 2 + 4 * n + 1 <= 8 v + 1
                x += (math.isqrt(8 * v + 1) - 1) // 2
            if x >= h: r = m - 1
            else: l = m + 1
        return l",1397981466
Yawn_Sean,Yawn_Sean,3,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        vis = set(bannedWords)
        return len([x for x in message if x in vis]) >= 2",1397981838
Yawn_Sean,Yawn_Sean,3,3572,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397981180
Yawn_Sean,Yawn_Sean,3,3573,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397980928
Sid123xyz,Sid123xyz,4,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def is_possible(time):
            total = 0
            for t in workerTimes:
                # We need to solve t * x * (x +1) /2 <= time
                # Which simplifies to x^2 +x - (2*time)/t <=0
                # Solve for x: x = floor( (-1 + sqrt(1 + 8*time/t)) / 2 )
                # To avoid floating point operations, use integer math
                if t == 0:
                    continue
                discriminant = 1 + (8 * time) // t
                if discriminant < 0:
                    continue
                sqrt_d = int(discriminant**0.5)
                x = (sqrt_d -1) // 2
                total += x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * (mountainHeight * (mountainHeight +1)) //2

        while left < right:
            mid = (left + right) //2
            if is_possible(mid):
                right = mid
            else:
                left = mid +1
        return left",1397970239
Sid123xyz,Sid123xyz,4,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        banned_count = 0

    
        for word in message:
            if word in banned_set:
                banned_count += 1
                # If two banned words are found, return True
                if banned_count >= 2:
                    return True

        # If fewer than two banned words are found, return False
        return False
 ",1397961384
Sid123xyz,Sid123xyz,4,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required_counts = defaultdict(int)
        for char in word2:
            required_counts[char] += 1
        required_unique = len(required_counts)

        left = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

        for right in range(n):
            character = word1[right]
            window_counts[character] += 1


            if character in required_counts and window_counts[character] == required_counts[character]:
                formed += 1

            while formed == required_unique:
                result += n - right

 
                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required_counts and window_counts[left_char] < required_counts[left_char]:
                    formed -= 1
                left += 1


        return result
",1397982052
Sid123xyz,Sid123xyz,4,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required = defaultdict(int)
        for char in word2:
            required[char] += 1
        required_unique = len(required)

        left = 0
        right = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

   
        while right < n:
            character = word1[right]
            window_counts[character] += 1

        
            if character in required and window_counts[character] == required[character]:
                formed += 1

        
            while left <= right and formed == required_unique:

                result += n - right  

                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required and window_counts[left_char] < required[left_char]:
                    formed -= 1
                left += 1

            right += 1

        return result
",1397975847
Rahul Shah,rsha256,6,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def helper(m):
            total = 0
            for wt in workerTimes:
                left_x = 0
                right_x = 2 * (10 ** 12)
                while left_x < right_x:
                    mid = (left_x + right_x + 1) // 2
                    cost = wt * mid * (mid + 1) // 2
                    if cost <= m:
                        left_x = mid
                    else:
                        right_x = mid - 1
                total += left_x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight +1) //2
        while left < right:
            mid = (left + right) // 2
            if helper(mid):
                right = mid
            else:
                left = mid + 1
        return left
",1397964841
Rahul Shah,rsha256,6,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        s = set(bannedWords)
        res = 0
        for w in message:
            if w in s:
                res += 1
                if res >= 2: return True
        return False
",1397971576
Rahul Shah,rsha256,6,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397983690
Rahul Shah,rsha256,6,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397982875
Capy,HapCapy,7,3496,python3,"from typing import List
import math

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def max_reducible_height(t):
            total = 0
            for wt in workerTimes:
                discriminant = 1 + (8 * t) // wt
                if discriminant < 0:
                    continue
                x = (math.sqrt(discriminant) - 1) / 2
                total += int(x)
                if total >= mountainHeight:
                    return total
            return total

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        while left < right:
            mid = (left + right) // 2
            if max_reducible_height(mid) >= mountainHeight:
                right = mid
            else:
                left = mid + 1
        return left
",1397974006
Capy,HapCapy,7,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned = set(bannedWords)
        return sum(word in banned for word in message) >= 2
",1397959223
Capy,HapCapy,7,3572,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397985440
Capy,HapCapy,7,3573,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397986255
Wangwang Yang,Jigcecile,8,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long H = mountainHeight;
        vector<long long> wTimes(workerTimes.begin(), workerTimes.end());
        int n = wTimes.size();
        long long Left = 0, Right = 1e16;

        auto getMaxX = [&](long long C) -> long long {
            long long Left = 0, Right = H;
            while (Left <= Right) {
                long long Mid = (Left + Right) / 2;
                long long val = Mid * Mid + Mid;
                if (val <= C) {
                    Left = Mid + 1;
                } else {
                    Right = Mid - 1;
                }
            }
            return Right;
        };

        while (Left < Right) {
            long long Mid = (Left + Right) / 2;
            long long total_x = 0;
            for (int i = 0; i < n; ++i) {
                long long w = wTimes[i];
                long long C = (2 * Mid) / w;
                long long x = getMaxX(C);
                total_x += x;
            }
            if (total_x >= H) {
                Right = Mid;
            } else {
                Left = Mid + 1;
            }
        }
        return Left;
    }
};",1397964893
Wangwang Yang,Jigcecile,8,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> bannedSet(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (bannedSet.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397959008
Wangwang Yang,Jigcecile,8,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> need(26, 0);
        for (char c : word2) {
            need[c - 'a']++;
        }

        vector<int> window(26, 0);
        int required = 0;
        for (int count : need) {
            if (count > 0)
                required++;
        }
        int formed = 0;

        int left = 0;
        long long totalValidSubstrings = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            window[c - 'a']++;
            if (need[c - 'a'] > 0 && window[c - 'a'] == need[c - 'a']) {
                formed++;
            }

            while (left <= right && formed == required) {
                totalValidSubstrings += N - right;

                char lc = word1[left];
                if (need[lc - 'a'] > 0 && window[lc - 'a'] == need[lc - 'a']) {
                    formed--;
                }
                window[lc - 'a']--;
                left++;
            }
        }
        return totalValidSubstrings;
    }
};",1397987330
Wangwang Yang,Jigcecile,8,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> requiredCounts(26, 0);
        for (char c : word2) {
            requiredCounts[c - 'a']++;
        }

        vector<int> windowCounts(26, 0);
        int left = 0;
        long long totalValidSubstrings = 0;
        int requiredChars = 0;

        for (int count : requiredCounts) {
            if (count > 0)
                requiredChars++;
        }

        int formedChars = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            windowCounts[c - 'a']++;

            if (windowCounts[c - 'a'] == requiredCounts[c - 'a']) {
                if (requiredCounts[c - 'a'] > 0) {
                    formedChars++;
                }
            }

            while (formedChars == requiredChars) {
                totalValidSubstrings += N - right;

                char leftChar = word1[left];
                if (windowCounts[leftChar - 'a'] ==
                    requiredCounts[leftChar - 'a']) {
                    if (requiredCounts[leftChar - 'a'] > 0) {
                        formedChars--;
                    }
                }
                windowCounts[leftChar - 'a']--;
                left++;
            }
        }

        return totalValidSubstrings;
    }
};",1397980390
jonathanirvings,jonathanirvings,9,3496,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

vector<pair<LL,int>> triangle;
vector<int> dat;
int h;

bool bisa(LL x)
{
  int total = 0;
  for (int y : dat)
  {
    LL t = x / y;
    vector<pair<LL,int>>::iterator it = upper_bound(ALL(triangle),mp(t,INF));
    --it;
    total += it->se;
    if (total >= h) return true;
  }
  return false;
}

class Solution {
public:
  long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
    if (SIZE(triangle) == 0)
    {
      FORN(i,0,100000)
      {
        triangle.pb(mp((LL)i * (i + 1) / 2, i));
      }
    }
    dat = workerTimes;
    h = mountainHeight;
    LL risan = INFF;
    LL L = 1;
    LL R = INFF;
    while (L <= R)
    {
      LL M = (L + R) >> 1;
      if (bisa(M))
      {
        risan = M;
        R = M - 1;
      } else L = M + 1;
    }
    return risan;
  }
};",1397975279
jonathanirvings,jonathanirvings,9,3541,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

class Solution {
public:
  bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
    set<string> banned(ALL(bannedWords));
    int ada = 0;
    for (string s : message)
    {
      if (banned.count(s)) ++ada;
    }   
    return ada >= 2;
  }
};",1397958787
jonathanirvings,jonathanirvings,9,3572,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987753
jonathanirvings,jonathanirvings,9,3573,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987955
lilPeep,stupidRR,11,3496,cpp,"class Solution {
    long long cnt(long long x)
    {
        long long low=0ll;
        long long high=1e9;
        long long ans=low;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            if((mid*mid+mid)/2ll <= x)
            {
                ans=mid;
                low=mid+1;
            }
            else
                high=mid-1;
        }
        return ans;
    }
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long x=mountainHeight;
        x=(x*x+x)/2ll;
        long long maxTime=*std::min_element(workerTimes.begin(),workerTimes.end());
        maxTime=maxTime*x;
        
        long long low=1;
        long long high=maxTime;
        long long ans=high;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            
            long long red=0ll;
            for(auto time : workerTimes)
                red=red+cnt(mid/time);
            
            if(red>=mountainHeight)
            {
                ans=mid;
                high=mid-1;
            }
            else
                low=mid+1;
        }
        return ans;
    }
};",1397976989
lilPeep,stupidRR,11,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        map<string,int> notAllowed;
        for(auto word : bannedWords)
            notAllowed[word]=1;
        
        int cnt=0;
        for(auto word : message)
            cnt=cnt+notAllowed[word];
        return (cnt>=2);
    }
};",1397960042
lilPeep,stupidRR,11,3572,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397988459
lilPeep,stupidRR,11,3573,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397987933
Ethan,ethanrao,12,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int h, std::vector<int>& t) {
        long long l = 1, r = 1e18; 
        while (l < r) {
            long long mid = l + (r - l) / 2; 
            long long tt = 0;
            for (int time : t) {
                tt += 1ll* (sqrt(1 + 1ll * 8 * mid / time) - 1) / 2;
                if (tt >= h) break;
            }
            if (tt >= h) r = mid;
            else l = mid + 1; 
        }

        return l; 
    }
};
",1397988704
Ethan,ethanrao,12,3541,cpp,"class Solution {
public:
    bool reportSpam(std::vector<std::string>& message, std::vector<std::string>& a) {

        std::unordered_set<std::string> st(a.begin(), a.end());
        int ct = 0;
        
        for (const auto& x : message) 
            if (st.find(x) != st.end()) 
                ct++;
   
        return ct >= 2;
    }
};
",1397982927
Ethan,ethanrao,12,3572,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397980911
Ethan,ethanrao,12,3573,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397982049
pingchungchang,pingchungchang,14,3496,cpp,"class Solution {
public:
#define ll long long
    ll f(ll dt,ll lim){
        lim /= dt;
        ll l = 0,r = 1e9;
        while(l != r){
            ll mid = (l+r+1)>>1;
            if(mid*(mid+1)/2<=lim)l = mid;
            else r = mid-1;
        }
        return l;
    }
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        ll l = 0,r = 1e18;
        while(l != r){
            ll mid = (l+r)>>1;
            ll s = 0;
            for(auto &i:workerTimes){
                s += f(i,mid);
            }
            if(s>=mountainHeight)r = mid;
            else l = mid+1;
        }
        return l;
    }
};",1397972226
pingchungchang,pingchungchang,14,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_map<string, int> mp;
        for (auto it: bannedWords) mp[it] = 1;
        int n = 0;
        for (auto it:message){
            if (mp.count(it) != 0) n++; 
        }
        if (n >= 2) return true;
        else return false;
    }
};",1397973583
pingchungchang,pingchungchang,14,3572,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397987874
pingchungchang,pingchungchang,14,3573,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397989212
Shivam,itshivam,15,3496,golang,"package main

import (
	
	""sort""
)

func minNumberOfSeconds(mountainHeight int, workerTimes []int) int64 {
	left := int64(min(workerTimes))                         
	right := int64(mountainHeight*(mountainHeight+1)) / 2 * left 

	for left < right {
		mid := left + (right-left)/2
		if canReduceAll(mountainHeight, workerTimes, mid) {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func canReduceAll(mountainHeight int, workerTimes []int, maxTime int64) bool {
	totalUnits := int64(0)

	for _, time := range workerTimes {
		low, high := int64(1), int64(mountainHeight)

		for low <= high {
			mid := low + (high-low)/2
			if canWork(time, mid) <= maxTime {
				low = mid + 1
			} else {
				high = mid - 1
			}
		}

		totalUnits += high
		if totalUnits >= int64(mountainHeight) {
			return true
		}
	}

	return totalUnits >= int64(mountainHeight)
}

func canWork(time int, x int64) int64 {
	return int64(time) * x * (x + 1) / 2
}

func min(arr []int) int {
	sort.Ints(arr)
	return arr[0]
}


",1397989329
Shivam,itshivam,15,3541,golang,"package main

import (
	""fmt""
)

func reportSpam(message []string, bannedWords []string) bool {
	bannedSet := make(map[string]struct{})
	for _, word := range bannedWords {
		bannedSet[word] = struct{}{}
	}

	count := 0
	for _, word := range message {
		if _, exists := bannedSet[word]; exists {
			count++
			if count == 2 {
				return true 
			}
		}
	}

	return false 
}


",1397985195
Shivam,itshivam,15,3572,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397983051
Shivam,itshivam,15,3573,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397982401
Abhishek kumar,abhishek-exists,17,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def can_reduce_in_time(time: int) -> bool:
            total_reduction = sum(
                int((((8 * time / worker_time) + 1) ** 0.5 - 1) / 2)
                for worker_time in workerTimes
            )
            return total_reduction >= mountainHeight

        left = 1
        right = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        
        # Apply bin search
        while left < right:
            mid = (left + right) // 2
            if can_reduce_in_time(mid):
                right = mid
            else:
                left = mid + 1

        return left",1397976783
Abhishek kumar,abhishek-exists,17,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        return sum(1 for word in message if word in banned_set) >= 2",1397960041
Abhishek kumar,abhishek-exists,17,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        required = len(target)
        formed = 0

        for right in range(len(word1)):
            # Expand the window
            current[word1[right]] += 1
            if word1[right] in target and current[word1[right]] == target[word1[right]]:
                formed += 1

            # Contract the window if all required characters are formed
            while formed == required:
                count += len(word1) - right
                
                # Remove the leftmost character
                if word1[left] in target and current[word1[left]] == target[word1[left]]:
                    formed -= 1
                current[word1[left]] -= 1
                left += 1

        return count",1397989816
Abhishek kumar,abhishek-exists,17,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        
        # Using sliding window
        for right in range(len(word1)):
            current[word1[right]] += 1
            
            while all(current[char] >= target[char] for char in target):
                count += len(word1) - right
                current[word1[left]] -= 1
                left += 1
        
        return count",1397984924
Ryan,ryanwong0127,18,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def get_max_x(m):
            if m < 0:
                return 0
            low_x, high_x = 0, m
            while low_x <= high_x:
                mid_x = (low_x + high_x) // 2
                if mid_x * (mid_x + 1) <= m:
                    low_x = mid_x + 1
                else:
                    high_x = mid_x - 1
            return high_x

        max_worker_time = max(workerTimes)
        H = mountainHeight
        t_upper = max_worker_time * H * (H + 1) // 2
        low, high = 0, t_upper

        while low < high:
            mid = (low + high) // 2
            s = 2 * mid
            total_x = 0
            for c in workerTimes:
                m = s // c
                x = get_max_x(m)
                total_x += x
            if total_x >= H:
                high = mid
            else:
                low = mid + 1
        return low",1397979559
Ryan,ryanwong0127,18,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        match_count = 0

        for word in message:
            if word in banned_set:
                match_count += 1
                if match_count >= 2:
                    return True

        return False",1397960562
Ryan,ryanwong0127,18,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397989585
Ryan,ryanwong0127,18,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397990058
Ian Wong,ianwong1999,19,3496,cpp,"class Solution {
public:
    using ull = long long;
    using P = pair<ull, int>;
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<P, vector<P>, greater<P>> pq;
        
        int n = workerTimes.size();
        
        vector<long long> vec(n);
        vector<long long> cnt(n);
        
        for (int i = 0; i < n; i++) {
            vec[i] = workerTimes[i];
            cnt[i] = 1;
            pq.emplace(workerTimes[i], i);
        }
        
        long long res = 0;
        cout << endl;
        while (mountainHeight > 0) {
            auto [cost, id] = pq.top(); pq.pop();
            res = max(res, cost);
            cnt[id]++;
            vec[id] += cnt[id] * workerTimes[id];
            pq.emplace(vec[id], id);
            mountainHeight--;
        }
        
        return res;
    }
};",1397976160
Ian Wong,ianwong1999,19,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        set<string> s;
        for (const auto& ss : bannedWords) s.insert(ss);
        
        
        int cnt = 0;
        for (const auto& ss : message) cnt += s.count(ss);
        
        return cnt >= 2;
    }
};",1397959019
Ian Wong,ianwong1999,19,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397990107
Ian Wong,ianwong1999,19,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397989569
a11,TravellingSalesman23,21,3496,cpp,"class Solution {
public:
    long long mountainHeight;
    vector<int> workerTimes;

    long long integer_sqrt(long long n) {
        if (n == 0 || n == 1)
            return n;
        long long left = 1, right = n;
        while (left <= right) {
            long long mid = left + (right - left) / 2;
            if (mid <= n / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    bool f(long long t) {
        long long sum_x = 0;
        for (int i = 0; i < workerTimes.size(); ++i) {
            long long A = workerTimes[i];
            if (A == 0) continue; 
            long long t_div_A = t / A;
            long long D = 1 + 8 * t_div_A;
            long long D_sqrt = integer_sqrt(D);
            long long x = (D_sqrt - 1) / 2;
            sum_x += x;
            if (sum_x >= mountainHeight)
                return true;
        }
        return sum_x >= mountainHeight;
    }

    long long minNumberOfSeconds(int mountainHeightParam, vector<int>& workerTimesParam) {
        mountainHeight = mountainHeightParam;
        workerTimes = workerTimesParam;

        long long low = 0, high = 1e18;
        while (low < high) {
            long long mid = (low + high) / 2;
            if (f(mid))
                high = mid;
            else
                low = mid + 1;
        }
        return low;
    }
};",1397983129
a11,TravellingSalesman23,21,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> banned_set(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (banned_set.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397987190
a11,TravellingSalesman23,21,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        vector<int> need(26, 0), have(26, 0);
        int required_chars = 0;
        int matched_chars = 0;  

        for (char c : word2) {
            if (need[c - 'a'] == 0) {
                required_chars++;
            }
            need[c - 'a']++;
        }

        int left = 0;
        long long total = 0;
        int N = word1.size();

        for (int right = 0; right < N; ++right) {
            int c = word1[right] - 'a';
            have[c]++;
            if (have[c] == need[c]) {
                matched_chars++;
            }

            while (left <= right && have[word1[left] - 'a'] > need[word1[left] - 'a']) {
                have[word1[left] - 'a']--;
                left++;
            }

            if (matched_chars == required_chars) {
                total += left + 1;
            }
        }

        return total;
    }
};",1397991250
a11,TravellingSalesman23,21,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int required_counts[26] = {0};
        for (char c : word2) {
            required_counts[c - 'a']++;
        }

        vector<int> letters;
        for (int c = 0; c < 26; ++c) {
            if (required_counts[c] > 0) {
                letters.push_back(c);
            }
        }
        vector<int> counts[26]; 
        vector<vector<int>> positions_c[26]; 

        for (int c : letters) {
            counts[c] = vector<int>(n + 1, 0);
            for (int pos = 1; pos <= n; ++pos) {
                counts[c][pos] = counts[c][pos - 1] + (word1[pos - 1] - 'a' == c ? 1 : 0);
            }

            int max_count = counts[c][n];
            positions_c[c] = vector<vector<int>>(max_count + 1);
            for (int pos = 0; pos <= n; ++pos) {
                int k = counts[c][pos];
                positions_c[c][k].push_back(pos);
            }
        }

        long long total = 0;

        for (int i = 1; i <= n; ++i) {
            int pos_max = -1;
            bool valid = true;

            for (int c : letters) {
                int counts_c_i_minus_1 = counts[c][i - 1];
                int K = counts_c_i_minus_1 + required_counts[c];

                if (K > counts[c][n]) {
                    valid = false;
                    break;
                }

                auto& positions = positions_c[c][K];
                auto it = lower_bound(positions.begin(), positions.end(), i);
                if (it == positions.end()) {
                    valid = false;
                    break;
                }
                int pos_c = *it;
                pos_max = max(pos_max, pos_c);
            }

            if (valid && pos_max <= n) {
                total += n - pos_max + 1;
            }
        }

        return total;
    }
};",1397979090
Ma Lin,Ma_Lin,22,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int H, vector<int>& a) {
        long long st = 1, ed = 10000000000000000LL, mid, res = 0, now, i, j, x;
        while (st <= ed){
            mid = (st + ed) / 2;
            now = H;
            for (auto q : a){
                if (q > mid) continue;
                x = (sqrt(1 + 8 * mid / q) - 1) / 2;
                now -= x;
                if (now <= 0) break;
            }
            
            if (now <= 0){
                res = mid;
                ed = mid - 1;
            }
            else st = mid + 1;
        }
        
        return res;
    }
};",1397981435
Ma Lin,Ma_Lin,22,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& a, vector<string>& b) {
        int ge = 0;
        unordered_set<string> S;
        for (auto w : b) S.insert(w);
        for (auto w : a)
            if (S.count(w)) ++ge;
        return ge >= 2;
    }
};",1397958958
Ma Lin,Ma_Lin,22,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991661
Ma Lin,Ma_Lin,22,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991001
Shacola,shacola,23,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T: int) -> bool:
            cnt = 0
            for time in workerTimes:
                if time == 0:
                    continue
                discriminant = 1 + 8 * T // time
                if discriminant < 0:
                    continue
                sqrt_discriminant = math.isqrt(discriminant)
                x = (sqrt_discriminant - 1) // 2
                if x > 0:
                    cnt += x
                if cnt >= mountainHeight:
                    return True
            return cnt >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * \
            (mountainHeight + 1) // 2

        ans = right
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        return ans",1397973858
Shacola,shacola,23,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        st = set(bannedWords)
        cnt = 0
        for word in message:
            if word in st:
                cnt += 1
                if cnt >= 2:
                    return True
        return False",1397965421
Shacola,shacola,23,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397992187
Shacola,shacola,23,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397984188
penguinhacker,penguinhacker,24,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
        for (int i : workerTimes)
            pq.push({i, i, 2});
        long long ans=0;
        while(mountainHeight--) {
            auto x=pq.top();
            pq.pop();
            ans=x[0];
            pq.push({x[0]+x[2]*x[1], x[1], x[2]+1});
        }
        return ans;
    }
};",1397973249
penguinhacker,penguinhacker,24,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& banned) {
        int cnt=0;
        set<string> s(banned.begin(), banned.end());
        for (string ss : message)
            cnt += s.count(ss);
        return cnt>=2;
    }
};",1397959294
penguinhacker,penguinhacker,24,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397981676
penguinhacker,penguinhacker,24,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397982248
Sambhav Jain,Sambhav-Jain,25,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) 
    {
        long long ans = 0;
        auto helper=[=](long long sum) -> int
        {
            long long ans = 0;
            for (long long start = 0, end = 1e9, mid; start <= end;)
            {
                mid = (start + end) / 2;
                if (mid * (mid + 1) / 2 <= sum)
                {
                    ans= mid;
                    start = mid + 1;
                }
                else
                {
                    end = mid - 1;
                }
            }
            return ans;
        };
        for (long long start = 0, end = 1e18, mid; start <= end;)
        {
            mid = (start + end) / 2;
            long long sum = 0;
            for (auto &i : workerTimes)
            {
                sum += helper(mid / i);
            }
            if (sum >= mountainHeight)
            {
                ans = mid;
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return ans;
    }
};",1397985093
Sambhav Jain,Sambhav-Jain,25,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) 
    {
        map<string, bool> amap;
        map<string, int> freq;
        for (auto &i : bannedWords)
        {
            amap[i] = true;
        }
        int cnt = 0;
        for (auto &i : message)
        {
           cnt += amap[i];
        }
        return (cnt >= 2);
        return false;
    }
};",1397962939
Sambhav Jain,Sambhav-Jain,25,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992682
Sambhav Jain,Sambhav-Jain,25,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992282
bpnew,bpnew,1,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T):
            total = 0
            for wt in workerTimes:
                S = (2 * T) // wt
                D = 1 + 4 * S
                if D < 0:
                    xi = 0
                else:
                    sqrt_D = int(D**0.5)
                    xi = (-1 + sqrt_D) // 2
                    while (xi + 1) * xi > S:
                        xi -= 1
                    while (xi + 1) * xi <= S:
                        xi += 1
                    xi -=1
                    xi = max(xi, 0)
                total += xi
            return total >= mountainHeight

        left, right = 0, 1 << 60
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left        ",1397971657
bpnew,bpnew,1,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = sum(1 for word in message if word in banned_set)
        return count >= 2        ",1397960528
bpnew,bpnew,1,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        N = len(word1)
        need = [0]*26
        for c in word2:
            need[ord(c)-ord('a')] +=1
        have = [0]*26
        letters_needed = [i for i in range(26) if need[i]>0]
        left = 0
        total = 0
        for right in range(N):
            c = ord(word1[right])-ord('a')
            have[c] +=1
            while all(have[i]>=need[i] for i in letters_needed):
                have[ord(word1[left])-ord('a')] -=1
                left +=1
            total += left
        return total        ",1397967513
bpnew,bpnew,1,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        counts_word2 = defaultdict(int)
        required_letters = set(word2)
        for c in word2:
            counts_word2[c] += 1

        N = len(word1)
        counts = defaultdict(int)
        total_substrings = 0
        left = 0
        right = 0

        while left < N:
            while right < N and any(counts[char] < counts_word2[char] for char in counts_word2):
                counts[word1[right]] +=1
                right +=1
            if any(counts[char] < counts_word2[char] for char in counts_word2):
                break
            total_substrings += N - right +1
            counts[word1[left]] -=1
            left +=1

        return total_substrings        ",1397970226
Konsept,konssept,2,3496,rust,"impl Solution {
    pub fn min_number_of_seconds(mountain_height: i32, worker_times: Vec<i32>) -> i64 {
        let mut low: i64 = 0;
        let mut high: i64 = 1e18 as i64;
        while low < high {
            let mid = low + (high - low) / 2;
            if Self::can_complete(mid, mountain_height, &worker_times) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        low
    }

    fn can_complete(time_limit: i64, mountain_height: i32, worker_times: &Vec<i32>) -> bool {
        let mut total_height_reduced: i64 = 0;
        for &t in worker_times {
            if t == 0 { continue; }
            let D = 1.0 + 8.0 * time_limit as f64 / t as f64;
            if D < 0.0 { continue; }
            let x = ((-1.0 + D.sqrt()) / 2.0) as i64;
            total_height_reduced += x;
            if total_height_reduced >= mountain_height as i64 {
                return true;
            }
        }
        total_height_reduced >= mountain_height as i64
    }
}",1397965114
Konsept,konssept,2,3541,rust,"use std::collections::HashSet;

impl Solution {
    pub fn report_spam(message: Vec<String>, banned_words: Vec<String>) -> bool {
        let banned_set: HashSet<String> = banned_words.into_iter().collect();
        
        let mut count = 0;
        for word in message {
            if banned_set.contains(&word) {
                count += 1;
                if count >= 2 {
                    return true;
                }
            }
        }
        
        false
    }
}",1397960425
Konsept,konssept,2,3572,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397968792
Konsept,konssept,2,3573,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397971736
Yawn_Sean,Yawn_Sean,3,3496,python3,"class Solution:
    def minNumberOfSeconds(self, h: int, ts: List[int]) -> int:
        l, r = 1, 10 ** 18
        while l <= r:
            m = (l + r) // 2
            x = 0
            for t in ts:
                v = m // t
                # (1 + n) * n / 2 <= v
                # 4 * n ^ 2 + 4 * n + 1 <= 8 v + 1
                x += (math.isqrt(8 * v + 1) - 1) // 2
            if x >= h: r = m - 1
            else: l = m + 1
        return l",1397981466
Yawn_Sean,Yawn_Sean,3,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        vis = set(bannedWords)
        return len([x for x in message if x in vis]) >= 2",1397981838
Yawn_Sean,Yawn_Sean,3,3572,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397981180
Yawn_Sean,Yawn_Sean,3,3573,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397980928
Sid123xyz,Sid123xyz,4,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def is_possible(time):
            total = 0
            for t in workerTimes:
                # We need to solve t * x * (x +1) /2 <= time
                # Which simplifies to x^2 +x - (2*time)/t <=0
                # Solve for x: x = floor( (-1 + sqrt(1 + 8*time/t)) / 2 )
                # To avoid floating point operations, use integer math
                if t == 0:
                    continue
                discriminant = 1 + (8 * time) // t
                if discriminant < 0:
                    continue
                sqrt_d = int(discriminant**0.5)
                x = (sqrt_d -1) // 2
                total += x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * (mountainHeight * (mountainHeight +1)) //2

        while left < right:
            mid = (left + right) //2
            if is_possible(mid):
                right = mid
            else:
                left = mid +1
        return left",1397970239
Sid123xyz,Sid123xyz,4,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        banned_count = 0

    
        for word in message:
            if word in banned_set:
                banned_count += 1
                # If two banned words are found, return True
                if banned_count >= 2:
                    return True

        # If fewer than two banned words are found, return False
        return False
 ",1397961384
Sid123xyz,Sid123xyz,4,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required_counts = defaultdict(int)
        for char in word2:
            required_counts[char] += 1
        required_unique = len(required_counts)

        left = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

        for right in range(n):
            character = word1[right]
            window_counts[character] += 1


            if character in required_counts and window_counts[character] == required_counts[character]:
                formed += 1

            while formed == required_unique:
                result += n - right

 
                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required_counts and window_counts[left_char] < required_counts[left_char]:
                    formed -= 1
                left += 1


        return result
",1397982052
Sid123xyz,Sid123xyz,4,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required = defaultdict(int)
        for char in word2:
            required[char] += 1
        required_unique = len(required)

        left = 0
        right = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

   
        while right < n:
            character = word1[right]
            window_counts[character] += 1

        
            if character in required and window_counts[character] == required[character]:
                formed += 1

        
            while left <= right and formed == required_unique:

                result += n - right  

                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required and window_counts[left_char] < required[left_char]:
                    formed -= 1
                left += 1

            right += 1

        return result
",1397975847
Rahul Shah,rsha256,6,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def helper(m):
            total = 0
            for wt in workerTimes:
                left_x = 0
                right_x = 2 * (10 ** 12)
                while left_x < right_x:
                    mid = (left_x + right_x + 1) // 2
                    cost = wt * mid * (mid + 1) // 2
                    if cost <= m:
                        left_x = mid
                    else:
                        right_x = mid - 1
                total += left_x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight +1) //2
        while left < right:
            mid = (left + right) // 2
            if helper(mid):
                right = mid
            else:
                left = mid + 1
        return left
",1397964841
Rahul Shah,rsha256,6,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        s = set(bannedWords)
        res = 0
        for w in message:
            if w in s:
                res += 1
                if res >= 2: return True
        return False
",1397971576
Rahul Shah,rsha256,6,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397983690
Rahul Shah,rsha256,6,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397982875
Capy,HapCapy,7,3496,python3,"from typing import List
import math

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def max_reducible_height(t):
            total = 0
            for wt in workerTimes:
                discriminant = 1 + (8 * t) // wt
                if discriminant < 0:
                    continue
                x = (math.sqrt(discriminant) - 1) / 2
                total += int(x)
                if total >= mountainHeight:
                    return total
            return total

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        while left < right:
            mid = (left + right) // 2
            if max_reducible_height(mid) >= mountainHeight:
                right = mid
            else:
                left = mid + 1
        return left
",1397974006
Capy,HapCapy,7,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned = set(bannedWords)
        return sum(word in banned for word in message) >= 2
",1397959223
Capy,HapCapy,7,3572,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397985440
Capy,HapCapy,7,3573,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397986255
Wangwang Yang,Jigcecile,8,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long H = mountainHeight;
        vector<long long> wTimes(workerTimes.begin(), workerTimes.end());
        int n = wTimes.size();
        long long Left = 0, Right = 1e16;

        auto getMaxX = [&](long long C) -> long long {
            long long Left = 0, Right = H;
            while (Left <= Right) {
                long long Mid = (Left + Right) / 2;
                long long val = Mid * Mid + Mid;
                if (val <= C) {
                    Left = Mid + 1;
                } else {
                    Right = Mid - 1;
                }
            }
            return Right;
        };

        while (Left < Right) {
            long long Mid = (Left + Right) / 2;
            long long total_x = 0;
            for (int i = 0; i < n; ++i) {
                long long w = wTimes[i];
                long long C = (2 * Mid) / w;
                long long x = getMaxX(C);
                total_x += x;
            }
            if (total_x >= H) {
                Right = Mid;
            } else {
                Left = Mid + 1;
            }
        }
        return Left;
    }
};",1397964893
Wangwang Yang,Jigcecile,8,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> bannedSet(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (bannedSet.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397959008
Wangwang Yang,Jigcecile,8,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> need(26, 0);
        for (char c : word2) {
            need[c - 'a']++;
        }

        vector<int> window(26, 0);
        int required = 0;
        for (int count : need) {
            if (count > 0)
                required++;
        }
        int formed = 0;

        int left = 0;
        long long totalValidSubstrings = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            window[c - 'a']++;
            if (need[c - 'a'] > 0 && window[c - 'a'] == need[c - 'a']) {
                formed++;
            }

            while (left <= right && formed == required) {
                totalValidSubstrings += N - right;

                char lc = word1[left];
                if (need[lc - 'a'] > 0 && window[lc - 'a'] == need[lc - 'a']) {
                    formed--;
                }
                window[lc - 'a']--;
                left++;
            }
        }
        return totalValidSubstrings;
    }
};",1397987330
Wangwang Yang,Jigcecile,8,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> requiredCounts(26, 0);
        for (char c : word2) {
            requiredCounts[c - 'a']++;
        }

        vector<int> windowCounts(26, 0);
        int left = 0;
        long long totalValidSubstrings = 0;
        int requiredChars = 0;

        for (int count : requiredCounts) {
            if (count > 0)
                requiredChars++;
        }

        int formedChars = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            windowCounts[c - 'a']++;

            if (windowCounts[c - 'a'] == requiredCounts[c - 'a']) {
                if (requiredCounts[c - 'a'] > 0) {
                    formedChars++;
                }
            }

            while (formedChars == requiredChars) {
                totalValidSubstrings += N - right;

                char leftChar = word1[left];
                if (windowCounts[leftChar - 'a'] ==
                    requiredCounts[leftChar - 'a']) {
                    if (requiredCounts[leftChar - 'a'] > 0) {
                        formedChars--;
                    }
                }
                windowCounts[leftChar - 'a']--;
                left++;
            }
        }

        return totalValidSubstrings;
    }
};",1397980390
jonathanirvings,jonathanirvings,9,3496,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

vector<pair<LL,int>> triangle;
vector<int> dat;
int h;

bool bisa(LL x)
{
  int total = 0;
  for (int y : dat)
  {
    LL t = x / y;
    vector<pair<LL,int>>::iterator it = upper_bound(ALL(triangle),mp(t,INF));
    --it;
    total += it->se;
    if (total >= h) return true;
  }
  return false;
}

class Solution {
public:
  long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
    if (SIZE(triangle) == 0)
    {
      FORN(i,0,100000)
      {
        triangle.pb(mp((LL)i * (i + 1) / 2, i));
      }
    }
    dat = workerTimes;
    h = mountainHeight;
    LL risan = INFF;
    LL L = 1;
    LL R = INFF;
    while (L <= R)
    {
      LL M = (L + R) >> 1;
      if (bisa(M))
      {
        risan = M;
        R = M - 1;
      } else L = M + 1;
    }
    return risan;
  }
};",1397975279
jonathanirvings,jonathanirvings,9,3541,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

class Solution {
public:
  bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
    set<string> banned(ALL(bannedWords));
    int ada = 0;
    for (string s : message)
    {
      if (banned.count(s)) ++ada;
    }   
    return ada >= 2;
  }
};",1397958787
jonathanirvings,jonathanirvings,9,3572,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987753
jonathanirvings,jonathanirvings,9,3573,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987955
lilPeep,stupidRR,11,3496,cpp,"class Solution {
    long long cnt(long long x)
    {
        long long low=0ll;
        long long high=1e9;
        long long ans=low;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            if((mid*mid+mid)/2ll <= x)
            {
                ans=mid;
                low=mid+1;
            }
            else
                high=mid-1;
        }
        return ans;
    }
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long x=mountainHeight;
        x=(x*x+x)/2ll;
        long long maxTime=*std::min_element(workerTimes.begin(),workerTimes.end());
        maxTime=maxTime*x;
        
        long long low=1;
        long long high=maxTime;
        long long ans=high;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            
            long long red=0ll;
            for(auto time : workerTimes)
                red=red+cnt(mid/time);
            
            if(red>=mountainHeight)
            {
                ans=mid;
                high=mid-1;
            }
            else
                low=mid+1;
        }
        return ans;
    }
};",1397976989
lilPeep,stupidRR,11,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        map<string,int> notAllowed;
        for(auto word : bannedWords)
            notAllowed[word]=1;
        
        int cnt=0;
        for(auto word : message)
            cnt=cnt+notAllowed[word];
        return (cnt>=2);
    }
};",1397960042
lilPeep,stupidRR,11,3572,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397988459
lilPeep,stupidRR,11,3573,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397987933
Ethan,ethanrao,12,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int h, std::vector<int>& t) {
        long long l = 1, r = 1e18; 
        while (l < r) {
            long long mid = l + (r - l) / 2; 
            long long tt = 0;
            for (int time : t) {
                tt += 1ll* (sqrt(1 + 1ll * 8 * mid / time) - 1) / 2;
                if (tt >= h) break;
            }
            if (tt >= h) r = mid;
            else l = mid + 1; 
        }

        return l; 
    }
};
",1397988704
Ethan,ethanrao,12,3541,cpp,"class Solution {
public:
    bool reportSpam(std::vector<std::string>& message, std::vector<std::string>& a) {

        std::unordered_set<std::string> st(a.begin(), a.end());
        int ct = 0;
        
        for (const auto& x : message) 
            if (st.find(x) != st.end()) 
                ct++;
   
        return ct >= 2;
    }
};
",1397982927
Ethan,ethanrao,12,3572,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397980911
Ethan,ethanrao,12,3573,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397982049
pingchungchang,pingchungchang,14,3496,cpp,"class Solution {
public:
#define ll long long
    ll f(ll dt,ll lim){
        lim /= dt;
        ll l = 0,r = 1e9;
        while(l != r){
            ll mid = (l+r+1)>>1;
            if(mid*(mid+1)/2<=lim)l = mid;
            else r = mid-1;
        }
        return l;
    }
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        ll l = 0,r = 1e18;
        while(l != r){
            ll mid = (l+r)>>1;
            ll s = 0;
            for(auto &i:workerTimes){
                s += f(i,mid);
            }
            if(s>=mountainHeight)r = mid;
            else l = mid+1;
        }
        return l;
    }
};",1397972226
pingchungchang,pingchungchang,14,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_map<string, int> mp;
        for (auto it: bannedWords) mp[it] = 1;
        int n = 0;
        for (auto it:message){
            if (mp.count(it) != 0) n++; 
        }
        if (n >= 2) return true;
        else return false;
    }
};",1397973583
pingchungchang,pingchungchang,14,3572,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397987874
pingchungchang,pingchungchang,14,3573,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397989212
Shivam,itshivam,15,3496,golang,"package main

import (
	
	""sort""
)

func minNumberOfSeconds(mountainHeight int, workerTimes []int) int64 {
	left := int64(min(workerTimes))                         
	right := int64(mountainHeight*(mountainHeight+1)) / 2 * left 

	for left < right {
		mid := left + (right-left)/2
		if canReduceAll(mountainHeight, workerTimes, mid) {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func canReduceAll(mountainHeight int, workerTimes []int, maxTime int64) bool {
	totalUnits := int64(0)

	for _, time := range workerTimes {
		low, high := int64(1), int64(mountainHeight)

		for low <= high {
			mid := low + (high-low)/2
			if canWork(time, mid) <= maxTime {
				low = mid + 1
			} else {
				high = mid - 1
			}
		}

		totalUnits += high
		if totalUnits >= int64(mountainHeight) {
			return true
		}
	}

	return totalUnits >= int64(mountainHeight)
}

func canWork(time int, x int64) int64 {
	return int64(time) * x * (x + 1) / 2
}

func min(arr []int) int {
	sort.Ints(arr)
	return arr[0]
}


",1397989329
Shivam,itshivam,15,3541,golang,"package main

import (
	""fmt""
)

func reportSpam(message []string, bannedWords []string) bool {
	bannedSet := make(map[string]struct{})
	for _, word := range bannedWords {
		bannedSet[word] = struct{}{}
	}

	count := 0
	for _, word := range message {
		if _, exists := bannedSet[word]; exists {
			count++
			if count == 2 {
				return true 
			}
		}
	}

	return false 
}


",1397985195
Shivam,itshivam,15,3572,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397983051
Shivam,itshivam,15,3573,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397982401
Abhishek kumar,abhishek-exists,17,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def can_reduce_in_time(time: int) -> bool:
            total_reduction = sum(
                int((((8 * time / worker_time) + 1) ** 0.5 - 1) / 2)
                for worker_time in workerTimes
            )
            return total_reduction >= mountainHeight

        left = 1
        right = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        
        # Apply bin search
        while left < right:
            mid = (left + right) // 2
            if can_reduce_in_time(mid):
                right = mid
            else:
                left = mid + 1

        return left",1397976783
Abhishek kumar,abhishek-exists,17,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        return sum(1 for word in message if word in banned_set) >= 2",1397960041
Abhishek kumar,abhishek-exists,17,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        required = len(target)
        formed = 0

        for right in range(len(word1)):
            # Expand the window
            current[word1[right]] += 1
            if word1[right] in target and current[word1[right]] == target[word1[right]]:
                formed += 1

            # Contract the window if all required characters are formed
            while formed == required:
                count += len(word1) - right
                
                # Remove the leftmost character
                if word1[left] in target and current[word1[left]] == target[word1[left]]:
                    formed -= 1
                current[word1[left]] -= 1
                left += 1

        return count",1397989816
Abhishek kumar,abhishek-exists,17,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        
        # Using sliding window
        for right in range(len(word1)):
            current[word1[right]] += 1
            
            while all(current[char] >= target[char] for char in target):
                count += len(word1) - right
                current[word1[left]] -= 1
                left += 1
        
        return count",1397984924
Ryan,ryanwong0127,18,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def get_max_x(m):
            if m < 0:
                return 0
            low_x, high_x = 0, m
            while low_x <= high_x:
                mid_x = (low_x + high_x) // 2
                if mid_x * (mid_x + 1) <= m:
                    low_x = mid_x + 1
                else:
                    high_x = mid_x - 1
            return high_x

        max_worker_time = max(workerTimes)
        H = mountainHeight
        t_upper = max_worker_time * H * (H + 1) // 2
        low, high = 0, t_upper

        while low < high:
            mid = (low + high) // 2
            s = 2 * mid
            total_x = 0
            for c in workerTimes:
                m = s // c
                x = get_max_x(m)
                total_x += x
            if total_x >= H:
                high = mid
            else:
                low = mid + 1
        return low",1397979559
Ryan,ryanwong0127,18,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        match_count = 0

        for word in message:
            if word in banned_set:
                match_count += 1
                if match_count >= 2:
                    return True

        return False",1397960562
Ryan,ryanwong0127,18,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397989585
Ryan,ryanwong0127,18,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397990058
Ian Wong,ianwong1999,19,3496,cpp,"class Solution {
public:
    using ull = long long;
    using P = pair<ull, int>;
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<P, vector<P>, greater<P>> pq;
        
        int n = workerTimes.size();
        
        vector<long long> vec(n);
        vector<long long> cnt(n);
        
        for (int i = 0; i < n; i++) {
            vec[i] = workerTimes[i];
            cnt[i] = 1;
            pq.emplace(workerTimes[i], i);
        }
        
        long long res = 0;
        cout << endl;
        while (mountainHeight > 0) {
            auto [cost, id] = pq.top(); pq.pop();
            res = max(res, cost);
            cnt[id]++;
            vec[id] += cnt[id] * workerTimes[id];
            pq.emplace(vec[id], id);
            mountainHeight--;
        }
        
        return res;
    }
};",1397976160
Ian Wong,ianwong1999,19,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        set<string> s;
        for (const auto& ss : bannedWords) s.insert(ss);
        
        
        int cnt = 0;
        for (const auto& ss : message) cnt += s.count(ss);
        
        return cnt >= 2;
    }
};",1397959019
Ian Wong,ianwong1999,19,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397990107
Ian Wong,ianwong1999,19,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397989569
a11,TravellingSalesman23,21,3496,cpp,"class Solution {
public:
    long long mountainHeight;
    vector<int> workerTimes;

    long long integer_sqrt(long long n) {
        if (n == 0 || n == 1)
            return n;
        long long left = 1, right = n;
        while (left <= right) {
            long long mid = left + (right - left) / 2;
            if (mid <= n / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    bool f(long long t) {
        long long sum_x = 0;
        for (int i = 0; i < workerTimes.size(); ++i) {
            long long A = workerTimes[i];
            if (A == 0) continue; 
            long long t_div_A = t / A;
            long long D = 1 + 8 * t_div_A;
            long long D_sqrt = integer_sqrt(D);
            long long x = (D_sqrt - 1) / 2;
            sum_x += x;
            if (sum_x >= mountainHeight)
                return true;
        }
        return sum_x >= mountainHeight;
    }

    long long minNumberOfSeconds(int mountainHeightParam, vector<int>& workerTimesParam) {
        mountainHeight = mountainHeightParam;
        workerTimes = workerTimesParam;

        long long low = 0, high = 1e18;
        while (low < high) {
            long long mid = (low + high) / 2;
            if (f(mid))
                high = mid;
            else
                low = mid + 1;
        }
        return low;
    }
};",1397983129
a11,TravellingSalesman23,21,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> banned_set(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (banned_set.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397987190
a11,TravellingSalesman23,21,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        vector<int> need(26, 0), have(26, 0);
        int required_chars = 0;
        int matched_chars = 0;  

        for (char c : word2) {
            if (need[c - 'a'] == 0) {
                required_chars++;
            }
            need[c - 'a']++;
        }

        int left = 0;
        long long total = 0;
        int N = word1.size();

        for (int right = 0; right < N; ++right) {
            int c = word1[right] - 'a';
            have[c]++;
            if (have[c] == need[c]) {
                matched_chars++;
            }

            while (left <= right && have[word1[left] - 'a'] > need[word1[left] - 'a']) {
                have[word1[left] - 'a']--;
                left++;
            }

            if (matched_chars == required_chars) {
                total += left + 1;
            }
        }

        return total;
    }
};",1397991250
a11,TravellingSalesman23,21,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int required_counts[26] = {0};
        for (char c : word2) {
            required_counts[c - 'a']++;
        }

        vector<int> letters;
        for (int c = 0; c < 26; ++c) {
            if (required_counts[c] > 0) {
                letters.push_back(c);
            }
        }
        vector<int> counts[26]; 
        vector<vector<int>> positions_c[26]; 

        for (int c : letters) {
            counts[c] = vector<int>(n + 1, 0);
            for (int pos = 1; pos <= n; ++pos) {
                counts[c][pos] = counts[c][pos - 1] + (word1[pos - 1] - 'a' == c ? 1 : 0);
            }

            int max_count = counts[c][n];
            positions_c[c] = vector<vector<int>>(max_count + 1);
            for (int pos = 0; pos <= n; ++pos) {
                int k = counts[c][pos];
                positions_c[c][k].push_back(pos);
            }
        }

        long long total = 0;

        for (int i = 1; i <= n; ++i) {
            int pos_max = -1;
            bool valid = true;

            for (int c : letters) {
                int counts_c_i_minus_1 = counts[c][i - 1];
                int K = counts_c_i_minus_1 + required_counts[c];

                if (K > counts[c][n]) {
                    valid = false;
                    break;
                }

                auto& positions = positions_c[c][K];
                auto it = lower_bound(positions.begin(), positions.end(), i);
                if (it == positions.end()) {
                    valid = false;
                    break;
                }
                int pos_c = *it;
                pos_max = max(pos_max, pos_c);
            }

            if (valid && pos_max <= n) {
                total += n - pos_max + 1;
            }
        }

        return total;
    }
};",1397979090
Ma Lin,Ma_Lin,22,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int H, vector<int>& a) {
        long long st = 1, ed = 10000000000000000LL, mid, res = 0, now, i, j, x;
        while (st <= ed){
            mid = (st + ed) / 2;
            now = H;
            for (auto q : a){
                if (q > mid) continue;
                x = (sqrt(1 + 8 * mid / q) - 1) / 2;
                now -= x;
                if (now <= 0) break;
            }
            
            if (now <= 0){
                res = mid;
                ed = mid - 1;
            }
            else st = mid + 1;
        }
        
        return res;
    }
};",1397981435
Ma Lin,Ma_Lin,22,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& a, vector<string>& b) {
        int ge = 0;
        unordered_set<string> S;
        for (auto w : b) S.insert(w);
        for (auto w : a)
            if (S.count(w)) ++ge;
        return ge >= 2;
    }
};",1397958958
Ma Lin,Ma_Lin,22,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991661
Ma Lin,Ma_Lin,22,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991001
Shacola,shacola,23,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T: int) -> bool:
            cnt = 0
            for time in workerTimes:
                if time == 0:
                    continue
                discriminant = 1 + 8 * T // time
                if discriminant < 0:
                    continue
                sqrt_discriminant = math.isqrt(discriminant)
                x = (sqrt_discriminant - 1) // 2
                if x > 0:
                    cnt += x
                if cnt >= mountainHeight:
                    return True
            return cnt >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * \
            (mountainHeight + 1) // 2

        ans = right
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        return ans",1397973858
Shacola,shacola,23,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        st = set(bannedWords)
        cnt = 0
        for word in message:
            if word in st:
                cnt += 1
                if cnt >= 2:
                    return True
        return False",1397965421
Shacola,shacola,23,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397992187
Shacola,shacola,23,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397984188
penguinhacker,penguinhacker,24,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
        for (int i : workerTimes)
            pq.push({i, i, 2});
        long long ans=0;
        while(mountainHeight--) {
            auto x=pq.top();
            pq.pop();
            ans=x[0];
            pq.push({x[0]+x[2]*x[1], x[1], x[2]+1});
        }
        return ans;
    }
};",1397973249
penguinhacker,penguinhacker,24,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& banned) {
        int cnt=0;
        set<string> s(banned.begin(), banned.end());
        for (string ss : message)
            cnt += s.count(ss);
        return cnt>=2;
    }
};",1397959294
penguinhacker,penguinhacker,24,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397981676
penguinhacker,penguinhacker,24,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397982248
Sambhav Jain,Sambhav-Jain,25,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) 
    {
        long long ans = 0;
        auto helper=[=](long long sum) -> int
        {
            long long ans = 0;
            for (long long start = 0, end = 1e9, mid; start <= end;)
            {
                mid = (start + end) / 2;
                if (mid * (mid + 1) / 2 <= sum)
                {
                    ans= mid;
                    start = mid + 1;
                }
                else
                {
                    end = mid - 1;
                }
            }
            return ans;
        };
        for (long long start = 0, end = 1e18, mid; start <= end;)
        {
            mid = (start + end) / 2;
            long long sum = 0;
            for (auto &i : workerTimes)
            {
                sum += helper(mid / i);
            }
            if (sum >= mountainHeight)
            {
                ans = mid;
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return ans;
    }
};",1397985093
Sambhav Jain,Sambhav-Jain,25,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) 
    {
        map<string, bool> amap;
        map<string, int> freq;
        for (auto &i : bannedWords)
        {
            amap[i] = true;
        }
        int cnt = 0;
        for (auto &i : message)
        {
           cnt += amap[i];
        }
        return (cnt >= 2);
        return false;
    }
};",1397962939
Sambhav Jain,Sambhav-Jain,25,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992682
Sambhav Jain,Sambhav-Jain,25,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992282
bpnew,bpnew,1,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T):
            total = 0
            for wt in workerTimes:
                S = (2 * T) // wt
                D = 1 + 4 * S
                if D < 0:
                    xi = 0
                else:
                    sqrt_D = int(D**0.5)
                    xi = (-1 + sqrt_D) // 2
                    while (xi + 1) * xi > S:
                        xi -= 1
                    while (xi + 1) * xi <= S:
                        xi += 1
                    xi -=1
                    xi = max(xi, 0)
                total += xi
            return total >= mountainHeight

        left, right = 0, 1 << 60
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left        ",1397971657
bpnew,bpnew,1,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = sum(1 for word in message if word in banned_set)
        return count >= 2        ",1397960528
bpnew,bpnew,1,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        N = len(word1)
        need = [0]*26
        for c in word2:
            need[ord(c)-ord('a')] +=1
        have = [0]*26
        letters_needed = [i for i in range(26) if need[i]>0]
        left = 0
        total = 0
        for right in range(N):
            c = ord(word1[right])-ord('a')
            have[c] +=1
            while all(have[i]>=need[i] for i in letters_needed):
                have[ord(word1[left])-ord('a')] -=1
                left +=1
            total += left
        return total        ",1397967513
bpnew,bpnew,1,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        counts_word2 = defaultdict(int)
        required_letters = set(word2)
        for c in word2:
            counts_word2[c] += 1

        N = len(word1)
        counts = defaultdict(int)
        total_substrings = 0
        left = 0
        right = 0

        while left < N:
            while right < N and any(counts[char] < counts_word2[char] for char in counts_word2):
                counts[word1[right]] +=1
                right +=1
            if any(counts[char] < counts_word2[char] for char in counts_word2):
                break
            total_substrings += N - right +1
            counts[word1[left]] -=1
            left +=1

        return total_substrings        ",1397970226
Konsept,konssept,2,3496,rust,"impl Solution {
    pub fn min_number_of_seconds(mountain_height: i32, worker_times: Vec<i32>) -> i64 {
        let mut low: i64 = 0;
        let mut high: i64 = 1e18 as i64;
        while low < high {
            let mid = low + (high - low) / 2;
            if Self::can_complete(mid, mountain_height, &worker_times) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        low
    }

    fn can_complete(time_limit: i64, mountain_height: i32, worker_times: &Vec<i32>) -> bool {
        let mut total_height_reduced: i64 = 0;
        for &t in worker_times {
            if t == 0 { continue; }
            let D = 1.0 + 8.0 * time_limit as f64 / t as f64;
            if D < 0.0 { continue; }
            let x = ((-1.0 + D.sqrt()) / 2.0) as i64;
            total_height_reduced += x;
            if total_height_reduced >= mountain_height as i64 {
                return true;
            }
        }
        total_height_reduced >= mountain_height as i64
    }
}",1397965114
Konsept,konssept,2,3541,rust,"use std::collections::HashSet;

impl Solution {
    pub fn report_spam(message: Vec<String>, banned_words: Vec<String>) -> bool {
        let banned_set: HashSet<String> = banned_words.into_iter().collect();
        
        let mut count = 0;
        for word in message {
            if banned_set.contains(&word) {
                count += 1;
                if count >= 2 {
                    return true;
                }
            }
        }
        
        false
    }
}",1397960425
Konsept,konssept,2,3572,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397968792
Konsept,konssept,2,3573,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397971736
Yawn_Sean,Yawn_Sean,3,3496,python3,"class Solution:
    def minNumberOfSeconds(self, h: int, ts: List[int]) -> int:
        l, r = 1, 10 ** 18
        while l <= r:
            m = (l + r) // 2
            x = 0
            for t in ts:
                v = m // t
                # (1 + n) * n / 2 <= v
                # 4 * n ^ 2 + 4 * n + 1 <= 8 v + 1
                x += (math.isqrt(8 * v + 1) - 1) // 2
            if x >= h: r = m - 1
            else: l = m + 1
        return l",1397981466
Yawn_Sean,Yawn_Sean,3,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        vis = set(bannedWords)
        return len([x for x in message if x in vis]) >= 2",1397981838
Yawn_Sean,Yawn_Sean,3,3572,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397981180
Yawn_Sean,Yawn_Sean,3,3573,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397980928
Sid123xyz,Sid123xyz,4,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def is_possible(time):
            total = 0
            for t in workerTimes:
                # We need to solve t * x * (x +1) /2 <= time
                # Which simplifies to x^2 +x - (2*time)/t <=0
                # Solve for x: x = floor( (-1 + sqrt(1 + 8*time/t)) / 2 )
                # To avoid floating point operations, use integer math
                if t == 0:
                    continue
                discriminant = 1 + (8 * time) // t
                if discriminant < 0:
                    continue
                sqrt_d = int(discriminant**0.5)
                x = (sqrt_d -1) // 2
                total += x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * (mountainHeight * (mountainHeight +1)) //2

        while left < right:
            mid = (left + right) //2
            if is_possible(mid):
                right = mid
            else:
                left = mid +1
        return left",1397970239
Sid123xyz,Sid123xyz,4,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        banned_count = 0

    
        for word in message:
            if word in banned_set:
                banned_count += 1
                # If two banned words are found, return True
                if banned_count >= 2:
                    return True

        # If fewer than two banned words are found, return False
        return False
 ",1397961384
Sid123xyz,Sid123xyz,4,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required_counts = defaultdict(int)
        for char in word2:
            required_counts[char] += 1
        required_unique = len(required_counts)

        left = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

        for right in range(n):
            character = word1[right]
            window_counts[character] += 1


            if character in required_counts and window_counts[character] == required_counts[character]:
                formed += 1

            while formed == required_unique:
                result += n - right

 
                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required_counts and window_counts[left_char] < required_counts[left_char]:
                    formed -= 1
                left += 1


        return result
",1397982052
Sid123xyz,Sid123xyz,4,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required = defaultdict(int)
        for char in word2:
            required[char] += 1
        required_unique = len(required)

        left = 0
        right = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

   
        while right < n:
            character = word1[right]
            window_counts[character] += 1

        
            if character in required and window_counts[character] == required[character]:
                formed += 1

        
            while left <= right and formed == required_unique:

                result += n - right  

                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required and window_counts[left_char] < required[left_char]:
                    formed -= 1
                left += 1

            right += 1

        return result
",1397975847
Rahul Shah,rsha256,6,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def helper(m):
            total = 0
            for wt in workerTimes:
                left_x = 0
                right_x = 2 * (10 ** 12)
                while left_x < right_x:
                    mid = (left_x + right_x + 1) // 2
                    cost = wt * mid * (mid + 1) // 2
                    if cost <= m:
                        left_x = mid
                    else:
                        right_x = mid - 1
                total += left_x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight +1) //2
        while left < right:
            mid = (left + right) // 2
            if helper(mid):
                right = mid
            else:
                left = mid + 1
        return left
",1397964841
Rahul Shah,rsha256,6,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        s = set(bannedWords)
        res = 0
        for w in message:
            if w in s:
                res += 1
                if res >= 2: return True
        return False
",1397971576
Rahul Shah,rsha256,6,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397983690
Rahul Shah,rsha256,6,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397982875
Capy,HapCapy,7,3496,python3,"from typing import List
import math

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def max_reducible_height(t):
            total = 0
            for wt in workerTimes:
                discriminant = 1 + (8 * t) // wt
                if discriminant < 0:
                    continue
                x = (math.sqrt(discriminant) - 1) / 2
                total += int(x)
                if total >= mountainHeight:
                    return total
            return total

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        while left < right:
            mid = (left + right) // 2
            if max_reducible_height(mid) >= mountainHeight:
                right = mid
            else:
                left = mid + 1
        return left
",1397974006
Capy,HapCapy,7,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned = set(bannedWords)
        return sum(word in banned for word in message) >= 2
",1397959223
Capy,HapCapy,7,3572,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397985440
Capy,HapCapy,7,3573,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397986255
Wangwang Yang,Jigcecile,8,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long H = mountainHeight;
        vector<long long> wTimes(workerTimes.begin(), workerTimes.end());
        int n = wTimes.size();
        long long Left = 0, Right = 1e16;

        auto getMaxX = [&](long long C) -> long long {
            long long Left = 0, Right = H;
            while (Left <= Right) {
                long long Mid = (Left + Right) / 2;
                long long val = Mid * Mid + Mid;
                if (val <= C) {
                    Left = Mid + 1;
                } else {
                    Right = Mid - 1;
                }
            }
            return Right;
        };

        while (Left < Right) {
            long long Mid = (Left + Right) / 2;
            long long total_x = 0;
            for (int i = 0; i < n; ++i) {
                long long w = wTimes[i];
                long long C = (2 * Mid) / w;
                long long x = getMaxX(C);
                total_x += x;
            }
            if (total_x >= H) {
                Right = Mid;
            } else {
                Left = Mid + 1;
            }
        }
        return Left;
    }
};",1397964893
Wangwang Yang,Jigcecile,8,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> bannedSet(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (bannedSet.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397959008
Wangwang Yang,Jigcecile,8,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> need(26, 0);
        for (char c : word2) {
            need[c - 'a']++;
        }

        vector<int> window(26, 0);
        int required = 0;
        for (int count : need) {
            if (count > 0)
                required++;
        }
        int formed = 0;

        int left = 0;
        long long totalValidSubstrings = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            window[c - 'a']++;
            if (need[c - 'a'] > 0 && window[c - 'a'] == need[c - 'a']) {
                formed++;
            }

            while (left <= right && formed == required) {
                totalValidSubstrings += N - right;

                char lc = word1[left];
                if (need[lc - 'a'] > 0 && window[lc - 'a'] == need[lc - 'a']) {
                    formed--;
                }
                window[lc - 'a']--;
                left++;
            }
        }
        return totalValidSubstrings;
    }
};",1397987330
Wangwang Yang,Jigcecile,8,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> requiredCounts(26, 0);
        for (char c : word2) {
            requiredCounts[c - 'a']++;
        }

        vector<int> windowCounts(26, 0);
        int left = 0;
        long long totalValidSubstrings = 0;
        int requiredChars = 0;

        for (int count : requiredCounts) {
            if (count > 0)
                requiredChars++;
        }

        int formedChars = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            windowCounts[c - 'a']++;

            if (windowCounts[c - 'a'] == requiredCounts[c - 'a']) {
                if (requiredCounts[c - 'a'] > 0) {
                    formedChars++;
                }
            }

            while (formedChars == requiredChars) {
                totalValidSubstrings += N - right;

                char leftChar = word1[left];
                if (windowCounts[leftChar - 'a'] ==
                    requiredCounts[leftChar - 'a']) {
                    if (requiredCounts[leftChar - 'a'] > 0) {
                        formedChars--;
                    }
                }
                windowCounts[leftChar - 'a']--;
                left++;
            }
        }

        return totalValidSubstrings;
    }
};",1397980390
jonathanirvings,jonathanirvings,9,3496,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

vector<pair<LL,int>> triangle;
vector<int> dat;
int h;

bool bisa(LL x)
{
  int total = 0;
  for (int y : dat)
  {
    LL t = x / y;
    vector<pair<LL,int>>::iterator it = upper_bound(ALL(triangle),mp(t,INF));
    --it;
    total += it->se;
    if (total >= h) return true;
  }
  return false;
}

class Solution {
public:
  long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
    if (SIZE(triangle) == 0)
    {
      FORN(i,0,100000)
      {
        triangle.pb(mp((LL)i * (i + 1) / 2, i));
      }
    }
    dat = workerTimes;
    h = mountainHeight;
    LL risan = INFF;
    LL L = 1;
    LL R = INFF;
    while (L <= R)
    {
      LL M = (L + R) >> 1;
      if (bisa(M))
      {
        risan = M;
        R = M - 1;
      } else L = M + 1;
    }
    return risan;
  }
};",1397975279
jonathanirvings,jonathanirvings,9,3541,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

class Solution {
public:
  bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
    set<string> banned(ALL(bannedWords));
    int ada = 0;
    for (string s : message)
    {
      if (banned.count(s)) ++ada;
    }   
    return ada >= 2;
  }
};",1397958787
jonathanirvings,jonathanirvings,9,3572,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987753
jonathanirvings,jonathanirvings,9,3573,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987955
lilPeep,stupidRR,11,3496,cpp,"class Solution {
    long long cnt(long long x)
    {
        long long low=0ll;
        long long high=1e9;
        long long ans=low;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            if((mid*mid+mid)/2ll <= x)
            {
                ans=mid;
                low=mid+1;
            }
            else
                high=mid-1;
        }
        return ans;
    }
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long x=mountainHeight;
        x=(x*x+x)/2ll;
        long long maxTime=*std::min_element(workerTimes.begin(),workerTimes.end());
        maxTime=maxTime*x;
        
        long long low=1;
        long long high=maxTime;
        long long ans=high;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            
            long long red=0ll;
            for(auto time : workerTimes)
                red=red+cnt(mid/time);
            
            if(red>=mountainHeight)
            {
                ans=mid;
                high=mid-1;
            }
            else
                low=mid+1;
        }
        return ans;
    }
};",1397976989
lilPeep,stupidRR,11,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        map<string,int> notAllowed;
        for(auto word : bannedWords)
            notAllowed[word]=1;
        
        int cnt=0;
        for(auto word : message)
            cnt=cnt+notAllowed[word];
        return (cnt>=2);
    }
};",1397960042
lilPeep,stupidRR,11,3572,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397988459
lilPeep,stupidRR,11,3573,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397987933
Ethan,ethanrao,12,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int h, std::vector<int>& t) {
        long long l = 1, r = 1e18; 
        while (l < r) {
            long long mid = l + (r - l) / 2; 
            long long tt = 0;
            for (int time : t) {
                tt += 1ll* (sqrt(1 + 1ll * 8 * mid / time) - 1) / 2;
                if (tt >= h) break;
            }
            if (tt >= h) r = mid;
            else l = mid + 1; 
        }

        return l; 
    }
};
",1397988704
Ethan,ethanrao,12,3541,cpp,"class Solution {
public:
    bool reportSpam(std::vector<std::string>& message, std::vector<std::string>& a) {

        std::unordered_set<std::string> st(a.begin(), a.end());
        int ct = 0;
        
        for (const auto& x : message) 
            if (st.find(x) != st.end()) 
                ct++;
   
        return ct >= 2;
    }
};
",1397982927
Ethan,ethanrao,12,3572,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397980911
Ethan,ethanrao,12,3573,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397982049
pingchungchang,pingchungchang,14,3496,cpp,"class Solution {
public:
#define ll long long
    ll f(ll dt,ll lim){
        lim /= dt;
        ll l = 0,r = 1e9;
        while(l != r){
            ll mid = (l+r+1)>>1;
            if(mid*(mid+1)/2<=lim)l = mid;
            else r = mid-1;
        }
        return l;
    }
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        ll l = 0,r = 1e18;
        while(l != r){
            ll mid = (l+r)>>1;
            ll s = 0;
            for(auto &i:workerTimes){
                s += f(i,mid);
            }
            if(s>=mountainHeight)r = mid;
            else l = mid+1;
        }
        return l;
    }
};",1397972226
pingchungchang,pingchungchang,14,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_map<string, int> mp;
        for (auto it: bannedWords) mp[it] = 1;
        int n = 0;
        for (auto it:message){
            if (mp.count(it) != 0) n++; 
        }
        if (n >= 2) return true;
        else return false;
    }
};",1397973583
pingchungchang,pingchungchang,14,3572,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397987874
pingchungchang,pingchungchang,14,3573,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397989212
Shivam,itshivam,15,3496,golang,"package main

import (
	
	""sort""
)

func minNumberOfSeconds(mountainHeight int, workerTimes []int) int64 {
	left := int64(min(workerTimes))                         
	right := int64(mountainHeight*(mountainHeight+1)) / 2 * left 

	for left < right {
		mid := left + (right-left)/2
		if canReduceAll(mountainHeight, workerTimes, mid) {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func canReduceAll(mountainHeight int, workerTimes []int, maxTime int64) bool {
	totalUnits := int64(0)

	for _, time := range workerTimes {
		low, high := int64(1), int64(mountainHeight)

		for low <= high {
			mid := low + (high-low)/2
			if canWork(time, mid) <= maxTime {
				low = mid + 1
			} else {
				high = mid - 1
			}
		}

		totalUnits += high
		if totalUnits >= int64(mountainHeight) {
			return true
		}
	}

	return totalUnits >= int64(mountainHeight)
}

func canWork(time int, x int64) int64 {
	return int64(time) * x * (x + 1) / 2
}

func min(arr []int) int {
	sort.Ints(arr)
	return arr[0]
}


",1397989329
Shivam,itshivam,15,3541,golang,"package main

import (
	""fmt""
)

func reportSpam(message []string, bannedWords []string) bool {
	bannedSet := make(map[string]struct{})
	for _, word := range bannedWords {
		bannedSet[word] = struct{}{}
	}

	count := 0
	for _, word := range message {
		if _, exists := bannedSet[word]; exists {
			count++
			if count == 2 {
				return true 
			}
		}
	}

	return false 
}


",1397985195
Shivam,itshivam,15,3572,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397983051
Shivam,itshivam,15,3573,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397982401
Abhishek kumar,abhishek-exists,17,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def can_reduce_in_time(time: int) -> bool:
            total_reduction = sum(
                int((((8 * time / worker_time) + 1) ** 0.5 - 1) / 2)
                for worker_time in workerTimes
            )
            return total_reduction >= mountainHeight

        left = 1
        right = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        
        # Apply bin search
        while left < right:
            mid = (left + right) // 2
            if can_reduce_in_time(mid):
                right = mid
            else:
                left = mid + 1

        return left",1397976783
Abhishek kumar,abhishek-exists,17,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        return sum(1 for word in message if word in banned_set) >= 2",1397960041
Abhishek kumar,abhishek-exists,17,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        required = len(target)
        formed = 0

        for right in range(len(word1)):
            # Expand the window
            current[word1[right]] += 1
            if word1[right] in target and current[word1[right]] == target[word1[right]]:
                formed += 1

            # Contract the window if all required characters are formed
            while formed == required:
                count += len(word1) - right
                
                # Remove the leftmost character
                if word1[left] in target and current[word1[left]] == target[word1[left]]:
                    formed -= 1
                current[word1[left]] -= 1
                left += 1

        return count",1397989816
Abhishek kumar,abhishek-exists,17,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        
        # Using sliding window
        for right in range(len(word1)):
            current[word1[right]] += 1
            
            while all(current[char] >= target[char] for char in target):
                count += len(word1) - right
                current[word1[left]] -= 1
                left += 1
        
        return count",1397984924
Ryan,ryanwong0127,18,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def get_max_x(m):
            if m < 0:
                return 0
            low_x, high_x = 0, m
            while low_x <= high_x:
                mid_x = (low_x + high_x) // 2
                if mid_x * (mid_x + 1) <= m:
                    low_x = mid_x + 1
                else:
                    high_x = mid_x - 1
            return high_x

        max_worker_time = max(workerTimes)
        H = mountainHeight
        t_upper = max_worker_time * H * (H + 1) // 2
        low, high = 0, t_upper

        while low < high:
            mid = (low + high) // 2
            s = 2 * mid
            total_x = 0
            for c in workerTimes:
                m = s // c
                x = get_max_x(m)
                total_x += x
            if total_x >= H:
                high = mid
            else:
                low = mid + 1
        return low",1397979559
Ryan,ryanwong0127,18,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        match_count = 0

        for word in message:
            if word in banned_set:
                match_count += 1
                if match_count >= 2:
                    return True

        return False",1397960562
Ryan,ryanwong0127,18,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397989585
Ryan,ryanwong0127,18,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397990058
Ian Wong,ianwong1999,19,3496,cpp,"class Solution {
public:
    using ull = long long;
    using P = pair<ull, int>;
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<P, vector<P>, greater<P>> pq;
        
        int n = workerTimes.size();
        
        vector<long long> vec(n);
        vector<long long> cnt(n);
        
        for (int i = 0; i < n; i++) {
            vec[i] = workerTimes[i];
            cnt[i] = 1;
            pq.emplace(workerTimes[i], i);
        }
        
        long long res = 0;
        cout << endl;
        while (mountainHeight > 0) {
            auto [cost, id] = pq.top(); pq.pop();
            res = max(res, cost);
            cnt[id]++;
            vec[id] += cnt[id] * workerTimes[id];
            pq.emplace(vec[id], id);
            mountainHeight--;
        }
        
        return res;
    }
};",1397976160
Ian Wong,ianwong1999,19,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        set<string> s;
        for (const auto& ss : bannedWords) s.insert(ss);
        
        
        int cnt = 0;
        for (const auto& ss : message) cnt += s.count(ss);
        
        return cnt >= 2;
    }
};",1397959019
Ian Wong,ianwong1999,19,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397990107
Ian Wong,ianwong1999,19,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397989569
a11,TravellingSalesman23,21,3496,cpp,"class Solution {
public:
    long long mountainHeight;
    vector<int> workerTimes;

    long long integer_sqrt(long long n) {
        if (n == 0 || n == 1)
            return n;
        long long left = 1, right = n;
        while (left <= right) {
            long long mid = left + (right - left) / 2;
            if (mid <= n / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    bool f(long long t) {
        long long sum_x = 0;
        for (int i = 0; i < workerTimes.size(); ++i) {
            long long A = workerTimes[i];
            if (A == 0) continue; 
            long long t_div_A = t / A;
            long long D = 1 + 8 * t_div_A;
            long long D_sqrt = integer_sqrt(D);
            long long x = (D_sqrt - 1) / 2;
            sum_x += x;
            if (sum_x >= mountainHeight)
                return true;
        }
        return sum_x >= mountainHeight;
    }

    long long minNumberOfSeconds(int mountainHeightParam, vector<int>& workerTimesParam) {
        mountainHeight = mountainHeightParam;
        workerTimes = workerTimesParam;

        long long low = 0, high = 1e18;
        while (low < high) {
            long long mid = (low + high) / 2;
            if (f(mid))
                high = mid;
            else
                low = mid + 1;
        }
        return low;
    }
};",1397983129
a11,TravellingSalesman23,21,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> banned_set(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (banned_set.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397987190
a11,TravellingSalesman23,21,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        vector<int> need(26, 0), have(26, 0);
        int required_chars = 0;
        int matched_chars = 0;  

        for (char c : word2) {
            if (need[c - 'a'] == 0) {
                required_chars++;
            }
            need[c - 'a']++;
        }

        int left = 0;
        long long total = 0;
        int N = word1.size();

        for (int right = 0; right < N; ++right) {
            int c = word1[right] - 'a';
            have[c]++;
            if (have[c] == need[c]) {
                matched_chars++;
            }

            while (left <= right && have[word1[left] - 'a'] > need[word1[left] - 'a']) {
                have[word1[left] - 'a']--;
                left++;
            }

            if (matched_chars == required_chars) {
                total += left + 1;
            }
        }

        return total;
    }
};",1397991250
a11,TravellingSalesman23,21,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int required_counts[26] = {0};
        for (char c : word2) {
            required_counts[c - 'a']++;
        }

        vector<int> letters;
        for (int c = 0; c < 26; ++c) {
            if (required_counts[c] > 0) {
                letters.push_back(c);
            }
        }
        vector<int> counts[26]; 
        vector<vector<int>> positions_c[26]; 

        for (int c : letters) {
            counts[c] = vector<int>(n + 1, 0);
            for (int pos = 1; pos <= n; ++pos) {
                counts[c][pos] = counts[c][pos - 1] + (word1[pos - 1] - 'a' == c ? 1 : 0);
            }

            int max_count = counts[c][n];
            positions_c[c] = vector<vector<int>>(max_count + 1);
            for (int pos = 0; pos <= n; ++pos) {
                int k = counts[c][pos];
                positions_c[c][k].push_back(pos);
            }
        }

        long long total = 0;

        for (int i = 1; i <= n; ++i) {
            int pos_max = -1;
            bool valid = true;

            for (int c : letters) {
                int counts_c_i_minus_1 = counts[c][i - 1];
                int K = counts_c_i_minus_1 + required_counts[c];

                if (K > counts[c][n]) {
                    valid = false;
                    break;
                }

                auto& positions = positions_c[c][K];
                auto it = lower_bound(positions.begin(), positions.end(), i);
                if (it == positions.end()) {
                    valid = false;
                    break;
                }
                int pos_c = *it;
                pos_max = max(pos_max, pos_c);
            }

            if (valid && pos_max <= n) {
                total += n - pos_max + 1;
            }
        }

        return total;
    }
};",1397979090
Ma Lin,Ma_Lin,22,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int H, vector<int>& a) {
        long long st = 1, ed = 10000000000000000LL, mid, res = 0, now, i, j, x;
        while (st <= ed){
            mid = (st + ed) / 2;
            now = H;
            for (auto q : a){
                if (q > mid) continue;
                x = (sqrt(1 + 8 * mid / q) - 1) / 2;
                now -= x;
                if (now <= 0) break;
            }
            
            if (now <= 0){
                res = mid;
                ed = mid - 1;
            }
            else st = mid + 1;
        }
        
        return res;
    }
};",1397981435
Ma Lin,Ma_Lin,22,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& a, vector<string>& b) {
        int ge = 0;
        unordered_set<string> S;
        for (auto w : b) S.insert(w);
        for (auto w : a)
            if (S.count(w)) ++ge;
        return ge >= 2;
    }
};",1397958958
Ma Lin,Ma_Lin,22,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991661
Ma Lin,Ma_Lin,22,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991001
Shacola,shacola,23,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T: int) -> bool:
            cnt = 0
            for time in workerTimes:
                if time == 0:
                    continue
                discriminant = 1 + 8 * T // time
                if discriminant < 0:
                    continue
                sqrt_discriminant = math.isqrt(discriminant)
                x = (sqrt_discriminant - 1) // 2
                if x > 0:
                    cnt += x
                if cnt >= mountainHeight:
                    return True
            return cnt >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * \
            (mountainHeight + 1) // 2

        ans = right
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        return ans",1397973858
Shacola,shacola,23,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        st = set(bannedWords)
        cnt = 0
        for word in message:
            if word in st:
                cnt += 1
                if cnt >= 2:
                    return True
        return False",1397965421
Shacola,shacola,23,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397992187
Shacola,shacola,23,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397984188
penguinhacker,penguinhacker,24,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
        for (int i : workerTimes)
            pq.push({i, i, 2});
        long long ans=0;
        while(mountainHeight--) {
            auto x=pq.top();
            pq.pop();
            ans=x[0];
            pq.push({x[0]+x[2]*x[1], x[1], x[2]+1});
        }
        return ans;
    }
};",1397973249
penguinhacker,penguinhacker,24,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& banned) {
        int cnt=0;
        set<string> s(banned.begin(), banned.end());
        for (string ss : message)
            cnt += s.count(ss);
        return cnt>=2;
    }
};",1397959294
penguinhacker,penguinhacker,24,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397981676
penguinhacker,penguinhacker,24,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397982248
Sambhav Jain,Sambhav-Jain,25,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) 
    {
        long long ans = 0;
        auto helper=[=](long long sum) -> int
        {
            long long ans = 0;
            for (long long start = 0, end = 1e9, mid; start <= end;)
            {
                mid = (start + end) / 2;
                if (mid * (mid + 1) / 2 <= sum)
                {
                    ans= mid;
                    start = mid + 1;
                }
                else
                {
                    end = mid - 1;
                }
            }
            return ans;
        };
        for (long long start = 0, end = 1e18, mid; start <= end;)
        {
            mid = (start + end) / 2;
            long long sum = 0;
            for (auto &i : workerTimes)
            {
                sum += helper(mid / i);
            }
            if (sum >= mountainHeight)
            {
                ans = mid;
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return ans;
    }
};",1397985093
Sambhav Jain,Sambhav-Jain,25,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) 
    {
        map<string, bool> amap;
        map<string, int> freq;
        for (auto &i : bannedWords)
        {
            amap[i] = true;
        }
        int cnt = 0;
        for (auto &i : message)
        {
           cnt += amap[i];
        }
        return (cnt >= 2);
        return false;
    }
};",1397962939
Sambhav Jain,Sambhav-Jain,25,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992682
Sambhav Jain,Sambhav-Jain,25,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992282
bpnew,bpnew,1,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T):
            total = 0
            for wt in workerTimes:
                S = (2 * T) // wt
                D = 1 + 4 * S
                if D < 0:
                    xi = 0
                else:
                    sqrt_D = int(D**0.5)
                    xi = (-1 + sqrt_D) // 2
                    while (xi + 1) * xi > S:
                        xi -= 1
                    while (xi + 1) * xi <= S:
                        xi += 1
                    xi -=1
                    xi = max(xi, 0)
                total += xi
            return total >= mountainHeight

        left, right = 0, 1 << 60
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left        ",1397971657
bpnew,bpnew,1,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = sum(1 for word in message if word in banned_set)
        return count >= 2        ",1397960528
bpnew,bpnew,1,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        N = len(word1)
        need = [0]*26
        for c in word2:
            need[ord(c)-ord('a')] +=1
        have = [0]*26
        letters_needed = [i for i in range(26) if need[i]>0]
        left = 0
        total = 0
        for right in range(N):
            c = ord(word1[right])-ord('a')
            have[c] +=1
            while all(have[i]>=need[i] for i in letters_needed):
                have[ord(word1[left])-ord('a')] -=1
                left +=1
            total += left
        return total        ",1397967513
bpnew,bpnew,1,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        counts_word2 = defaultdict(int)
        required_letters = set(word2)
        for c in word2:
            counts_word2[c] += 1

        N = len(word1)
        counts = defaultdict(int)
        total_substrings = 0
        left = 0
        right = 0

        while left < N:
            while right < N and any(counts[char] < counts_word2[char] for char in counts_word2):
                counts[word1[right]] +=1
                right +=1
            if any(counts[char] < counts_word2[char] for char in counts_word2):
                break
            total_substrings += N - right +1
            counts[word1[left]] -=1
            left +=1

        return total_substrings        ",1397970226
Konsept,konssept,2,3496,rust,"impl Solution {
    pub fn min_number_of_seconds(mountain_height: i32, worker_times: Vec<i32>) -> i64 {
        let mut low: i64 = 0;
        let mut high: i64 = 1e18 as i64;
        while low < high {
            let mid = low + (high - low) / 2;
            if Self::can_complete(mid, mountain_height, &worker_times) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        low
    }

    fn can_complete(time_limit: i64, mountain_height: i32, worker_times: &Vec<i32>) -> bool {
        let mut total_height_reduced: i64 = 0;
        for &t in worker_times {
            if t == 0 { continue; }
            let D = 1.0 + 8.0 * time_limit as f64 / t as f64;
            if D < 0.0 { continue; }
            let x = ((-1.0 + D.sqrt()) / 2.0) as i64;
            total_height_reduced += x;
            if total_height_reduced >= mountain_height as i64 {
                return true;
            }
        }
        total_height_reduced >= mountain_height as i64
    }
}",1397965114
Konsept,konssept,2,3541,rust,"use std::collections::HashSet;

impl Solution {
    pub fn report_spam(message: Vec<String>, banned_words: Vec<String>) -> bool {
        let banned_set: HashSet<String> = banned_words.into_iter().collect();
        
        let mut count = 0;
        for word in message {
            if banned_set.contains(&word) {
                count += 1;
                if count >= 2 {
                    return true;
                }
            }
        }
        
        false
    }
}",1397960425
Konsept,konssept,2,3572,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397968792
Konsept,konssept,2,3573,rust,"impl Solution {
    pub fn valid_substring_count(word1: String, word2: String) -> i64 {
        let word1_chars: Vec<char> = word1.chars().collect();
        let word2_chars: Vec<char> = word2.chars().collect();
        let n = word1_chars.len();
        let mut word2_counts = [0i32; 26];
        for &c in &word2_chars {
            word2_counts[c as usize - 'a' as usize] += 1;
        }

        let mut window_counts = [0i32; 26];
        let mut total_missing = word2.len() as i32;
        let mut left = 0usize;
        let mut total_count = 0i64;

        for right in 0..n {
            let c = word1_chars[right];
            let idx = c as usize - 'a' as usize;
            if word2_counts[idx] > 0 {
                window_counts[idx] += 1;
                if window_counts[idx] <= word2_counts[idx] {
                    total_missing -= 1;
                }
            }

            while total_missing == 0 {
                total_count += (n - right) as i64;
                let left_char = word1_chars[left];
                let left_idx = left_char as usize - 'a' as usize;
                if word2_counts[left_idx] > 0 {
                    window_counts[left_idx] -= 1;
                    if window_counts[left_idx] < word2_counts[left_idx] {
                        total_missing += 1;
                    }
                }
                left += 1;
            }
        }

        total_count
    }
}
",1397971736
Yawn_Sean,Yawn_Sean,3,3496,python3,"class Solution:
    def minNumberOfSeconds(self, h: int, ts: List[int]) -> int:
        l, r = 1, 10 ** 18
        while l <= r:
            m = (l + r) // 2
            x = 0
            for t in ts:
                v = m // t
                # (1 + n) * n / 2 <= v
                # 4 * n ^ 2 + 4 * n + 1 <= 8 v + 1
                x += (math.isqrt(8 * v + 1) - 1) // 2
            if x >= h: r = m - 1
            else: l = m + 1
        return l",1397981466
Yawn_Sean,Yawn_Sean,3,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        vis = set(bannedWords)
        return len([x for x in message if x in vis]) >= 2",1397981838
Yawn_Sean,Yawn_Sean,3,3572,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397981180
Yawn_Sean,Yawn_Sean,3,3573,python3,"class Solution:
    def validSubstringCount(self, s: str, word2: str) -> int:
        cnt = Counter(word2)
        l = r = 0
        
        ncnt = Counter()
        cur = 0
        
        ans = 0
        
        n = len(s)
        while l < n:
            while r < n and cur < len(cnt):
                if s[r] in cnt:
                    ncnt[s[r]] += 1
                    if ncnt[s[r]] == cnt[s[r]]:
                        cur += 1
                r += 1
                
            if cur < len(cnt): break
            ans += n - r + 1
            
            if s[l] in cnt:
                if ncnt[s[l]] == cnt[s[l]]:
                    cur -= 1
                ncnt[s[l]] -= 1
            l += 1
        return ans",1397980928
Sid123xyz,Sid123xyz,4,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def is_possible(time):
            total = 0
            for t in workerTimes:
                # We need to solve t * x * (x +1) /2 <= time
                # Which simplifies to x^2 +x - (2*time)/t <=0
                # Solve for x: x = floor( (-1 + sqrt(1 + 8*time/t)) / 2 )
                # To avoid floating point operations, use integer math
                if t == 0:
                    continue
                discriminant = 1 + (8 * time) // t
                if discriminant < 0:
                    continue
                sqrt_d = int(discriminant**0.5)
                x = (sqrt_d -1) // 2
                total += x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * (mountainHeight * (mountainHeight +1)) //2

        while left < right:
            mid = (left + right) //2
            if is_possible(mid):
                right = mid
            else:
                left = mid +1
        return left",1397970239
Sid123xyz,Sid123xyz,4,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        banned_count = 0

    
        for word in message:
            if word in banned_set:
                banned_count += 1
                # If two banned words are found, return True
                if banned_count >= 2:
                    return True

        # If fewer than two banned words are found, return False
        return False
 ",1397961384
Sid123xyz,Sid123xyz,4,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required_counts = defaultdict(int)
        for char in word2:
            required_counts[char] += 1
        required_unique = len(required_counts)

        left = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

        for right in range(n):
            character = word1[right]
            window_counts[character] += 1


            if character in required_counts and window_counts[character] == required_counts[character]:
                formed += 1

            while formed == required_unique:
                result += n - right

 
                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required_counts and window_counts[left_char] < required_counts[left_char]:
                    formed -= 1
                left += 1


        return result
",1397982052
Sid123xyz,Sid123xyz,4,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        required = defaultdict(int)
        for char in word2:
            required[char] += 1
        required_unique = len(required)

        left = 0
        right = 0
        formed = 0
        window_counts = defaultdict(int)
        result = 0
        n = len(word1)

   
        while right < n:
            character = word1[right]
            window_counts[character] += 1

        
            if character in required and window_counts[character] == required[character]:
                formed += 1

        
            while left <= right and formed == required_unique:

                result += n - right  

                left_char = word1[left]
                window_counts[left_char] -= 1
                if left_char in required and window_counts[left_char] < required[left_char]:
                    formed -= 1
                left += 1

            right += 1

        return result
",1397975847
Rahul Shah,rsha256,6,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def helper(m):
            total = 0
            for wt in workerTimes:
                left_x = 0
                right_x = 2 * (10 ** 12)
                while left_x < right_x:
                    mid = (left_x + right_x + 1) // 2
                    cost = wt * mid * (mid + 1) // 2
                    if cost <= m:
                        left_x = mid
                    else:
                        right_x = mid - 1
                total += left_x
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight +1) //2
        while left < right:
            mid = (left + right) // 2
            if helper(mid):
                right = mid
            else:
                left = mid + 1
        return left
",1397964841
Rahul Shah,rsha256,6,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        s = set(bannedWords)
        res = 0
        for w in message:
            if w in s:
                res += 1
                if res >= 2: return True
        return False
",1397971576
Rahul Shah,rsha256,6,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397983690
Rahul Shah,rsha256,6,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        arr = [0] * 26
        for c in word2:
            arr[ord(c) - ord('a')] += 1
        arr_unique = sum(1 for count in arr if count > 0)
        left = right = cnt = res = 0
        window = [0] * 26
        n = len(word1)
        for right in range(n):
            index = ord(word1[right]) - ord('a')
            window[index] += 1
            if arr[index] > 0 and window[index] == arr[index]:
                cnt += 1
            while left <= right and cnt == arr_unique:
                res += n - right
                left_index = ord(word1[left]) - ord('a')
                window[left_index] -= 1
                if arr[left_index] > 0 and window[left_index] < arr[left_index]:
                    cnt -= 1
                left += 1
        return res
        ",1397982875
Capy,HapCapy,7,3496,python3,"from typing import List
import math

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def max_reducible_height(t):
            total = 0
            for wt in workerTimes:
                discriminant = 1 + (8 * t) // wt
                if discriminant < 0:
                    continue
                x = (math.sqrt(discriminant) - 1) / 2
                total += int(x)
                if total >= mountainHeight:
                    return total
            return total

        left, right = 0, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        while left < right:
            mid = (left + right) // 2
            if max_reducible_height(mid) >= mountainHeight:
                right = mid
            else:
                left = mid + 1
        return left
",1397974006
Capy,HapCapy,7,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned = set(bannedWords)
        return sum(word in banned for word in message) >= 2
",1397959223
Capy,HapCapy,7,3572,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397985440
Capy,HapCapy,7,3573,python3,"from typing import List

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        if not word2:
            return (len(word1) * (len(word1) + 1)) // 2
        req = [0] * 26
        for c in word2:
            req[ord(c) - ord('a')] += 1
        required = sum(1 for x in req if x > 0)
        window = [0] * 26
        formed = 0
        left = 0
        count = 0
        for right, c in enumerate(word1):
            idx = ord(c) - ord('a')
            window[idx] += 1
            if req[idx] and window[idx] == req[idx]:
                formed += 1
            if formed == required:
                while formed == required:
                    count += len(word1) - right
                    left_idx = ord(word1[left]) - ord('a')
                    window[left_idx] -= 1
                    if req[left_idx] and window[left_idx] < req[left_idx]:
                        formed -= 1
                    left += 1
        return count",1397986255
Wangwang Yang,Jigcecile,8,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long H = mountainHeight;
        vector<long long> wTimes(workerTimes.begin(), workerTimes.end());
        int n = wTimes.size();
        long long Left = 0, Right = 1e16;

        auto getMaxX = [&](long long C) -> long long {
            long long Left = 0, Right = H;
            while (Left <= Right) {
                long long Mid = (Left + Right) / 2;
                long long val = Mid * Mid + Mid;
                if (val <= C) {
                    Left = Mid + 1;
                } else {
                    Right = Mid - 1;
                }
            }
            return Right;
        };

        while (Left < Right) {
            long long Mid = (Left + Right) / 2;
            long long total_x = 0;
            for (int i = 0; i < n; ++i) {
                long long w = wTimes[i];
                long long C = (2 * Mid) / w;
                long long x = getMaxX(C);
                total_x += x;
            }
            if (total_x >= H) {
                Right = Mid;
            } else {
                Left = Mid + 1;
            }
        }
        return Left;
    }
};",1397964893
Wangwang Yang,Jigcecile,8,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> bannedSet(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (bannedSet.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397959008
Wangwang Yang,Jigcecile,8,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> need(26, 0);
        for (char c : word2) {
            need[c - 'a']++;
        }

        vector<int> window(26, 0);
        int required = 0;
        for (int count : need) {
            if (count > 0)
                required++;
        }
        int formed = 0;

        int left = 0;
        long long totalValidSubstrings = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            window[c - 'a']++;
            if (need[c - 'a'] > 0 && window[c - 'a'] == need[c - 'a']) {
                formed++;
            }

            while (left <= right && formed == required) {
                totalValidSubstrings += N - right;

                char lc = word1[left];
                if (need[lc - 'a'] > 0 && window[lc - 'a'] == need[lc - 'a']) {
                    formed--;
                }
                window[lc - 'a']--;
                left++;
            }
        }
        return totalValidSubstrings;
    }
};",1397987330
Wangwang Yang,Jigcecile,8,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        const int N = word1.size();
        const int M = word2.size();
        vector<int> requiredCounts(26, 0);
        for (char c : word2) {
            requiredCounts[c - 'a']++;
        }

        vector<int> windowCounts(26, 0);
        int left = 0;
        long long totalValidSubstrings = 0;
        int requiredChars = 0;

        for (int count : requiredCounts) {
            if (count > 0)
                requiredChars++;
        }

        int formedChars = 0;

        for (int right = 0; right < N; ++right) {
            char c = word1[right];
            windowCounts[c - 'a']++;

            if (windowCounts[c - 'a'] == requiredCounts[c - 'a']) {
                if (requiredCounts[c - 'a'] > 0) {
                    formedChars++;
                }
            }

            while (formedChars == requiredChars) {
                totalValidSubstrings += N - right;

                char leftChar = word1[left];
                if (windowCounts[leftChar - 'a'] ==
                    requiredCounts[leftChar - 'a']) {
                    if (requiredCounts[leftChar - 'a'] > 0) {
                        formedChars--;
                    }
                }
                windowCounts[leftChar - 'a']--;
                left++;
            }
        }

        return totalValidSubstrings;
    }
};",1397980390
jonathanirvings,jonathanirvings,9,3496,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

vector<pair<LL,int>> triangle;
vector<int> dat;
int h;

bool bisa(LL x)
{
  int total = 0;
  for (int y : dat)
  {
    LL t = x / y;
    vector<pair<LL,int>>::iterator it = upper_bound(ALL(triangle),mp(t,INF));
    --it;
    total += it->se;
    if (total >= h) return true;
  }
  return false;
}

class Solution {
public:
  long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
    if (SIZE(triangle) == 0)
    {
      FORN(i,0,100000)
      {
        triangle.pb(mp((LL)i * (i + 1) / 2, i));
      }
    }
    dat = workerTimes;
    h = mountainHeight;
    LL risan = INFF;
    LL L = 1;
    LL R = INFF;
    while (L <= R)
    {
      LL M = (L + R) >> 1;
      if (bisa(M))
      {
        risan = M;
        R = M - 1;
      } else L = M + 1;
    }
    return risan;
  }
};",1397975279
jonathanirvings,jonathanirvings,9,3541,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

class Solution {
public:
  bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
    set<string> banned(ALL(bannedWords));
    int ada = 0;
    for (string s : message)
    {
      if (banned.count(s)) ++ada;
    }   
    return ada >= 2;
  }
};",1397958787
jonathanirvings,jonathanirvings,9,3572,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987753
jonathanirvings,jonathanirvings,9,3573,cpp,"//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,""====TESTING====\n"")
  #define VALUE(x) cerr << ""The value of "" << #x << "" is "" << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,""%lld"",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,""%lld"",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf(""%s"",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + "".in"").c_str (), ""r"", stdin);
  freopen ((s + "".out"").c_str (), ""w"", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

int ada[26];
vi pos[26];
int now[26];

class Solution {
public:
  long long validSubstringCount(string word1, string word2) {
    REP(i,26)
    {
      ada[i] = 0;
      pos[i].clear();
      now[i] = 0;
    }
    for (char c : word2) ++ada[c - 'a'];
    int n = SIZE(word1);
    REP(i,n) pos[word1[i] - 'a'].pb(i);
    LL risan = 0;
    REP(i,n)
    {
      int maks = 0;
      REP(j,26) if (ada[j])
      {
        if (now[j] + ada[j] - 1 < SIZE(pos[j])) MAX(maks,pos[j][now[j] + ada[j] - 1]);
        else MAX(maks,n);
      }
      risan += n - maks;
      ++now[word1[i] - 'a'];
    }
    return risan;
  }
};",1397987955
lilPeep,stupidRR,11,3496,cpp,"class Solution {
    long long cnt(long long x)
    {
        long long low=0ll;
        long long high=1e9;
        long long ans=low;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            if((mid*mid+mid)/2ll <= x)
            {
                ans=mid;
                low=mid+1;
            }
            else
                high=mid-1;
        }
        return ans;
    }
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        long long x=mountainHeight;
        x=(x*x+x)/2ll;
        long long maxTime=*std::min_element(workerTimes.begin(),workerTimes.end());
        maxTime=maxTime*x;
        
        long long low=1;
        long long high=maxTime;
        long long ans=high;
        while(low<=high)
        {
            long long mid=(low+high)/2;
            
            long long red=0ll;
            for(auto time : workerTimes)
                red=red+cnt(mid/time);
            
            if(red>=mountainHeight)
            {
                ans=mid;
                high=mid-1;
            }
            else
                low=mid+1;
        }
        return ans;
    }
};",1397976989
lilPeep,stupidRR,11,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        map<string,int> notAllowed;
        for(auto word : bannedWords)
            notAllowed[word]=1;
        
        int cnt=0;
        for(auto word : message)
            cnt=cnt+notAllowed[word];
        return (cnt>=2);
    }
};",1397960042
lilPeep,stupidRR,11,3572,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397988459
lilPeep,stupidRR,11,3573,cpp,"class Solution {
    bool over(vector<int>&a,vector<int>&b)
    {
        for(int i=0;i<26;i++)
        {
            if(b[i]>a[i])
                return false;
        }
        return true;
    }
public:
    long long validSubstringCount(string word1, string word2) {
        long long ans=0ll;
        vector<int> req(26);
        for(auto ele : word2)
            req[ele-'a']++;
        
        int right=0;
        vector<int> curr(26);
        for(int i=0;i<word1.size();i++)
        {
            while(right<word1.size() && over(curr,req)==false)
            {
                curr[ word1[right]-'a' ]++;
                right++;
            }
            
            if(over(curr,req))
                ans=ans+word1.size()+1ll-right;
            
            curr[ word1[i]-'a' ]--;
        }
        
        return ans;
    }
};",1397987933
Ethan,ethanrao,12,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int h, std::vector<int>& t) {
        long long l = 1, r = 1e18; 
        while (l < r) {
            long long mid = l + (r - l) / 2; 
            long long tt = 0;
            for (int time : t) {
                tt += 1ll* (sqrt(1 + 1ll * 8 * mid / time) - 1) / 2;
                if (tt >= h) break;
            }
            if (tt >= h) r = mid;
            else l = mid + 1; 
        }

        return l; 
    }
};
",1397988704
Ethan,ethanrao,12,3541,cpp,"class Solution {
public:
    bool reportSpam(std::vector<std::string>& message, std::vector<std::string>& a) {

        std::unordered_set<std::string> st(a.begin(), a.end());
        int ct = 0;
        
        for (const auto& x : message) 
            if (st.find(x) != st.end()) 
                ct++;
   
        return ct >= 2;
    }
};
",1397982927
Ethan,ethanrao,12,3572,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397980911
Ethan,ethanrao,12,3573,cpp,"class Solution {
public:
    int c1[26], c2[26];
    long long validSubstringCount(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        string word1 = ' ' + w1, word2 = ' ' + w2;
        long long ans = 0ll;
        for(int i = 1; i <= m; ++i) ++c2[word2[i] - 'a'];
        int fick = 0;
        for(int i = 0; i < 26; ++i) if(c2[i] > c1[i]) fick++;
        int r = 0;
        while(fick && r < n){
            ++r;
            ++c1[word1[r] - 'a'];
            if(c1[word1[r] - 'a'] == c2[word1[r] - 'a']) --fick;
        }
        if(fick) return 0;
        int t = r;
        for(int l = 1; r <= n; ++r){
            if(t != r) ++c1[word1[r] - 'a'];
            while(c1[word1[l] - 'a'] > c2[word1[l] - 'a']){
                --c1[word1[l] - 'a'];
                ++l;
            }
            ans += 1ll * l;
        }
        return ans;
    }
};",1397982049
pingchungchang,pingchungchang,14,3496,cpp,"class Solution {
public:
#define ll long long
    ll f(ll dt,ll lim){
        lim /= dt;
        ll l = 0,r = 1e9;
        while(l != r){
            ll mid = (l+r+1)>>1;
            if(mid*(mid+1)/2<=lim)l = mid;
            else r = mid-1;
        }
        return l;
    }
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        ll l = 0,r = 1e18;
        while(l != r){
            ll mid = (l+r)>>1;
            ll s = 0;
            for(auto &i:workerTimes){
                s += f(i,mid);
            }
            if(s>=mountainHeight)r = mid;
            else l = mid+1;
        }
        return l;
    }
};",1397972226
pingchungchang,pingchungchang,14,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_map<string, int> mp;
        for (auto it: bannedWords) mp[it] = 1;
        int n = 0;
        for (auto it:message){
            if (mp.count(it) != 0) n++; 
        }
        if (n >= 2) return true;
        else return false;
    }
};",1397973583
pingchungchang,pingchungchang,14,3572,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397987874
pingchungchang,pingchungchang,14,3573,cpp,"class Solution {
public:
#define ll long long
    bool check(vector<int> &a,vector<int> &tar){
        for(int i = 0;i<26;i++){
            if(a[i]<tar[i])return false;
        }
        return true;
    }
    long long validSubstringCount(string word1, string word2) {
        vector<int> cnt(26,0);
        vector<int> tar(26,0);
        int n = word1.size(),m = word2.size();
        for(auto &i:word2)tar[i-'a']++;
        int pt = 0;
        while(pt<n&&!check(cnt,tar)){
            cnt[word1[pt]-'a']++;
            pt++;
        }
        ll ans = 0;
        if(check(cnt,tar))ans += n-pt+1;
        for(int i = 0;i<n;i++){
            cnt[word1[i]-'a']--;
            while(pt<n&&!check(cnt,tar)){
                cnt[word1[pt]-'a']++;
                pt++;
            }
            if(check(cnt,tar))ans += n-pt+1;
        }
        return ans;
    }
};",1397989212
Shivam,itshivam,15,3496,golang,"package main

import (
	
	""sort""
)

func minNumberOfSeconds(mountainHeight int, workerTimes []int) int64 {
	left := int64(min(workerTimes))                         
	right := int64(mountainHeight*(mountainHeight+1)) / 2 * left 

	for left < right {
		mid := left + (right-left)/2
		if canReduceAll(mountainHeight, workerTimes, mid) {
			right = mid
		} else {
			left = mid + 1
		}
	}
	return left
}

func canReduceAll(mountainHeight int, workerTimes []int, maxTime int64) bool {
	totalUnits := int64(0)

	for _, time := range workerTimes {
		low, high := int64(1), int64(mountainHeight)

		for low <= high {
			mid := low + (high-low)/2
			if canWork(time, mid) <= maxTime {
				low = mid + 1
			} else {
				high = mid - 1
			}
		}

		totalUnits += high
		if totalUnits >= int64(mountainHeight) {
			return true
		}
	}

	return totalUnits >= int64(mountainHeight)
}

func canWork(time int, x int64) int64 {
	return int64(time) * x * (x + 1) / 2
}

func min(arr []int) int {
	sort.Ints(arr)
	return arr[0]
}


",1397989329
Shivam,itshivam,15,3541,golang,"package main

import (
	""fmt""
)

func reportSpam(message []string, bannedWords []string) bool {
	bannedSet := make(map[string]struct{})
	for _, word := range bannedWords {
		bannedSet[word] = struct{}{}
	}

	count := 0
	for _, word := range message {
		if _, exists := bannedSet[word]; exists {
			count++
			if count == 2 {
				return true 
			}
		}
	}

	return false 
}


",1397985195
Shivam,itshivam,15,3572,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397983051
Shivam,itshivam,15,3573,golang,"package main

import ""fmt""

func validSubstringCount(word1 string, word2 string) int64 {
    n := len(word1)

    b := make([]int, 26)
    for _, c := range word2 {
        b[c-'a']++
    }

    a := make([]int, 26) 
    var r int64 = 0      
    l := 0             

    for right := 0; right < n; right++ {
        a[word1[right]-'a']++

        for isWindowValid(a, b) {
            r += int64(n - right)
            a[word1[l]-'a']--
            l++
        }
    }

    return r
}

func isWindowValid(a []int, b []int) bool {
    for i := 0; i < 26; i++ {
        if b[i] > 0 && a[i] < b[i] {
            return false
        }
    }
    return true
}
",1397982401
Abhishek kumar,abhishek-exists,17,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def can_reduce_in_time(time: int) -> bool:
            total_reduction = sum(
                int((((8 * time / worker_time) + 1) ** 0.5 - 1) / 2)
                for worker_time in workerTimes
            )
            return total_reduction >= mountainHeight

        left = 1
        right = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2
        
        # Apply bin search
        while left < right:
            mid = (left + right) // 2
            if can_reduce_in_time(mid):
                right = mid
            else:
                left = mid + 1

        return left",1397976783
Abhishek kumar,abhishek-exists,17,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        return sum(1 for word in message if word in banned_set) >= 2",1397960041
Abhishek kumar,abhishek-exists,17,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        required = len(target)
        formed = 0

        for right in range(len(word1)):
            # Expand the window
            current[word1[right]] += 1
            if word1[right] in target and current[word1[right]] == target[word1[right]]:
                formed += 1

            # Contract the window if all required characters are formed
            while formed == required:
                count += len(word1) - right
                
                # Remove the leftmost character
                if word1[left] in target and current[word1[left]] == target[word1[left]]:
                    formed -= 1
                current[word1[left]] -= 1
                left += 1

        return count",1397989816
Abhishek kumar,abhishek-exists,17,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        target = Counter(word2)
        current = Counter()
        count, left = 0, 0
        
        # Using sliding window
        for right in range(len(word1)):
            current[word1[right]] += 1
            
            while all(current[char] >= target[char] for char in target):
                count += len(word1) - right
                current[word1[left]] -= 1
                left += 1
        
        return count",1397984924
Ryan,ryanwong0127,18,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def get_max_x(m):
            if m < 0:
                return 0
            low_x, high_x = 0, m
            while low_x <= high_x:
                mid_x = (low_x + high_x) // 2
                if mid_x * (mid_x + 1) <= m:
                    low_x = mid_x + 1
                else:
                    high_x = mid_x - 1
            return high_x

        max_worker_time = max(workerTimes)
        H = mountainHeight
        t_upper = max_worker_time * H * (H + 1) // 2
        low, high = 0, t_upper

        while low < high:
            mid = (low + high) // 2
            s = 2 * mid
            total_x = 0
            for c in workerTimes:
                m = s // c
                x = get_max_x(m)
                total_x += x
            if total_x >= H:
                high = mid
            else:
                low = mid + 1
        return low",1397979559
Ryan,ryanwong0127,18,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        match_count = 0

        for word in message:
            if word in banned_set:
                match_count += 1
                if match_count >= 2:
                    return True

        return False",1397960562
Ryan,ryanwong0127,18,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397989585
Ryan,ryanwong0127,18,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        from collections import defaultdict

        n = len(word1)
        required_counts = [0] * 26
        for ch in word2:
            required_counts[ord(ch) - ord('a')] +=1

        total_required = sum(required_counts)
        counts = [0]*26
        missing = total_required
        left = 0
        res = 0

        for right in range(n):
            idx = ord(word1[right]) - ord('a')
            counts[idx] +=1
            if required_counts[idx] > 0 and counts[idx] <= required_counts[idx]:
                missing -=1

            while missing ==0:
                res += n - right
                idx_left = ord(word1[left]) - ord('a')
                if required_counts[idx_left] > 0 and counts[idx_left] <= required_counts[idx_left]:
                    missing +=1
                counts[idx_left] -=1
                left +=1

        return res",1397990058
Ian Wong,ianwong1999,19,3496,cpp,"class Solution {
public:
    using ull = long long;
    using P = pair<ull, int>;
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<P, vector<P>, greater<P>> pq;
        
        int n = workerTimes.size();
        
        vector<long long> vec(n);
        vector<long long> cnt(n);
        
        for (int i = 0; i < n; i++) {
            vec[i] = workerTimes[i];
            cnt[i] = 1;
            pq.emplace(workerTimes[i], i);
        }
        
        long long res = 0;
        cout << endl;
        while (mountainHeight > 0) {
            auto [cost, id] = pq.top(); pq.pop();
            res = max(res, cost);
            cnt[id]++;
            vec[id] += cnt[id] * workerTimes[id];
            pq.emplace(vec[id], id);
            mountainHeight--;
        }
        
        return res;
    }
};",1397976160
Ian Wong,ianwong1999,19,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        set<string> s;
        for (const auto& ss : bannedWords) s.insert(ss);
        
        
        int cnt = 0;
        for (const auto& ss : message) cnt += s.count(ss);
        
        return cnt >= 2;
    }
};",1397959019
Ian Wong,ianwong1999,19,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397990107
Ian Wong,ianwong1999,19,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        if (m > n) return 0;
        
        vector<int> cnt(26);
        
        for (auto ch : word2) cnt[ch - 'a']++;
        
        int pt = 0;
        long long res = 0;
        
        auto trial = [&]() {
            for (int i = 0; i < 26; i++) if (cnt[i] > 0) {
                return false;
            }
            
            return true;
        };
        
        for (int i = 0; i < n; i++) {
            while (pt < n && !trial()) {
                cnt[word1[pt++] - 'a']--;
            }
            
            if (pt == n && !trial()) break;
            res += n - pt + 1;
            
            cnt[word1[i] - 'a']++;
        }
        
        return res;
    }
};",1397989569
a11,TravellingSalesman23,21,3496,cpp,"class Solution {
public:
    long long mountainHeight;
    vector<int> workerTimes;

    long long integer_sqrt(long long n) {
        if (n == 0 || n == 1)
            return n;
        long long left = 1, right = n;
        while (left <= right) {
            long long mid = left + (right - left) / 2;
            if (mid <= n / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    bool f(long long t) {
        long long sum_x = 0;
        for (int i = 0; i < workerTimes.size(); ++i) {
            long long A = workerTimes[i];
            if (A == 0) continue; 
            long long t_div_A = t / A;
            long long D = 1 + 8 * t_div_A;
            long long D_sqrt = integer_sqrt(D);
            long long x = (D_sqrt - 1) / 2;
            sum_x += x;
            if (sum_x >= mountainHeight)
                return true;
        }
        return sum_x >= mountainHeight;
    }

    long long minNumberOfSeconds(int mountainHeightParam, vector<int>& workerTimesParam) {
        mountainHeight = mountainHeightParam;
        workerTimes = workerTimesParam;

        long long low = 0, high = 1e18;
        while (low < high) {
            long long mid = (low + high) / 2;
            if (f(mid))
                high = mid;
            else
                low = mid + 1;
        }
        return low;
    }
};",1397983129
a11,TravellingSalesman23,21,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {
        unordered_set<string> banned_set(bannedWords.begin(), bannedWords.end());
        int count = 0;
        for (const string& word : message) {
            if (banned_set.count(word)) {
                count++;
                if (count >= 2) {
                    return true;
                }
            }
        }
        return false;
    }
};",1397987190
a11,TravellingSalesman23,21,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        vector<int> need(26, 0), have(26, 0);
        int required_chars = 0;
        int matched_chars = 0;  

        for (char c : word2) {
            if (need[c - 'a'] == 0) {
                required_chars++;
            }
            need[c - 'a']++;
        }

        int left = 0;
        long long total = 0;
        int N = word1.size();

        for (int right = 0; right < N; ++right) {
            int c = word1[right] - 'a';
            have[c]++;
            if (have[c] == need[c]) {
                matched_chars++;
            }

            while (left <= right && have[word1[left] - 'a'] > need[word1[left] - 'a']) {
                have[word1[left] - 'a']--;
                left++;
            }

            if (matched_chars == required_chars) {
                total += left + 1;
            }
        }

        return total;
    }
};",1397991250
a11,TravellingSalesman23,21,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int n = word1.size();
        int required_counts[26] = {0};
        for (char c : word2) {
            required_counts[c - 'a']++;
        }

        vector<int> letters;
        for (int c = 0; c < 26; ++c) {
            if (required_counts[c] > 0) {
                letters.push_back(c);
            }
        }
        vector<int> counts[26]; 
        vector<vector<int>> positions_c[26]; 

        for (int c : letters) {
            counts[c] = vector<int>(n + 1, 0);
            for (int pos = 1; pos <= n; ++pos) {
                counts[c][pos] = counts[c][pos - 1] + (word1[pos - 1] - 'a' == c ? 1 : 0);
            }

            int max_count = counts[c][n];
            positions_c[c] = vector<vector<int>>(max_count + 1);
            for (int pos = 0; pos <= n; ++pos) {
                int k = counts[c][pos];
                positions_c[c][k].push_back(pos);
            }
        }

        long long total = 0;

        for (int i = 1; i <= n; ++i) {
            int pos_max = -1;
            bool valid = true;

            for (int c : letters) {
                int counts_c_i_minus_1 = counts[c][i - 1];
                int K = counts_c_i_minus_1 + required_counts[c];

                if (K > counts[c][n]) {
                    valid = false;
                    break;
                }

                auto& positions = positions_c[c][K];
                auto it = lower_bound(positions.begin(), positions.end(), i);
                if (it == positions.end()) {
                    valid = false;
                    break;
                }
                int pos_c = *it;
                pos_max = max(pos_max, pos_c);
            }

            if (valid && pos_max <= n) {
                total += n - pos_max + 1;
            }
        }

        return total;
    }
};",1397979090
Ma Lin,Ma_Lin,22,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int H, vector<int>& a) {
        long long st = 1, ed = 10000000000000000LL, mid, res = 0, now, i, j, x;
        while (st <= ed){
            mid = (st + ed) / 2;
            now = H;
            for (auto q : a){
                if (q > mid) continue;
                x = (sqrt(1 + 8 * mid / q) - 1) / 2;
                now -= x;
                if (now <= 0) break;
            }
            
            if (now <= 0){
                res = mid;
                ed = mid - 1;
            }
            else st = mid + 1;
        }
        
        return res;
    }
};",1397981435
Ma Lin,Ma_Lin,22,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& a, vector<string>& b) {
        int ge = 0;
        unordered_set<string> S;
        for (auto w : b) S.insert(w);
        for (auto w : a)
            if (S.count(w)) ++ge;
        return ge >= 2;
    }
};",1397958958
Ma Lin,Ma_Lin,22,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991661
Ma Lin,Ma_Lin,22,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string a, string b) {
        long long res = 0;
        int yao[26], now[26], C = 0, i, j = -1, n = a.size();
        char c;
        for (i = 0; i < 26; ++i) yao[i] = now[i] = 0;
        for (auto qc : b) ++yao[qc - 'a'];
        for (i = 0; i < 26; ++i)
            if (yao[i] == 0) ++C;
        
        for (i = 0; i < n; ++i){
            if (i - 1 >= 0){
                c = a[i - 1] - 'a';
                if (now[c]-- == yao[c]) --C;
            }
            
            while (j + 1 < n && C < 26){
                c = a[++j] - 'a';
                if (++now[c] == yao[c]) ++C;
            }
            
            if (C >= 26) res += n - j;
        }
        
        return res;
    }
};",1397991001
Shacola,shacola,23,3496,python3,"class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        def check(T: int) -> bool:
            cnt = 0
            for time in workerTimes:
                if time == 0:
                    continue
                discriminant = 1 + 8 * T // time
                if discriminant < 0:
                    continue
                sqrt_discriminant = math.isqrt(discriminant)
                x = (sqrt_discriminant - 1) // 2
                if x > 0:
                    cnt += x
                if cnt >= mountainHeight:
                    return True
            return cnt >= mountainHeight

        left, right = 0, max(workerTimes) * mountainHeight * \
            (mountainHeight + 1) // 2

        ans = right
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        return ans",1397973858
Shacola,shacola,23,3541,python3,"class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        st = set(bannedWords)
        cnt = 0
        for word in message:
            if word in st:
                cnt += 1
                if cnt >= 2:
                    return True
        return False",1397965421
Shacola,shacola,23,3572,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397992187
Shacola,shacola,23,3573,python3,"class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        cnt2 = Counter(word2)
        required = len(cnt2)
        cnt = defaultdict(int) # window
        ans = left = formed = 0
        n = len(word1)
        for right in range(n):
            ch = word1[right]
            cnt[ch] += 1
            if ch in cnt2 and cnt[ch] == cnt2[ch]:
                formed += 1
            while left <= right and formed == required:
                ans += n - right
                ch = word1[left]
                cnt[ch] -= 1
                if ch in cnt2 and cnt[ch] < cnt2[ch]:
                    formed -= 1
                left += 1
        return ans",1397984188
penguinhacker,penguinhacker,24,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) {
        priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
        for (int i : workerTimes)
            pq.push({i, i, 2});
        long long ans=0;
        while(mountainHeight--) {
            auto x=pq.top();
            pq.pop();
            ans=x[0];
            pq.push({x[0]+x[2]*x[1], x[1], x[2]+1});
        }
        return ans;
    }
};",1397973249
penguinhacker,penguinhacker,24,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& banned) {
        int cnt=0;
        set<string> s(banned.begin(), banned.end());
        for (string ss : message)
            cnt += s.count(ss);
        return cnt>=2;
    }
};",1397959294
penguinhacker,penguinhacker,24,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397981676
penguinhacker,penguinhacker,24,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int cnt[26]={};
        for (char c : word2)
            ++cnt[c-'a'];
        long long ans=0;
        for (int i=0, j=0; i<word1.size(); ++i) {
            while(j<word1.size()&&*max_element(cnt, cnt+26)>0) {
                --cnt[word1[j]-'a'];
                ++j;
            }
            if (*max_element(cnt, cnt+26)>0)
                break;
            ans+=word1.size()+1-j;
            ++cnt[word1[i]-'a'];
        }
        return ans;
    }
};",1397982248
Sambhav Jain,Sambhav-Jain,25,3496,cpp,"class Solution {
public:
    long long minNumberOfSeconds(int mountainHeight, vector<int>& workerTimes) 
    {
        long long ans = 0;
        auto helper=[=](long long sum) -> int
        {
            long long ans = 0;
            for (long long start = 0, end = 1e9, mid; start <= end;)
            {
                mid = (start + end) / 2;
                if (mid * (mid + 1) / 2 <= sum)
                {
                    ans= mid;
                    start = mid + 1;
                }
                else
                {
                    end = mid - 1;
                }
            }
            return ans;
        };
        for (long long start = 0, end = 1e18, mid; start <= end;)
        {
            mid = (start + end) / 2;
            long long sum = 0;
            for (auto &i : workerTimes)
            {
                sum += helper(mid / i);
            }
            if (sum >= mountainHeight)
            {
                ans = mid;
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return ans;
    }
};",1397985093
Sambhav Jain,Sambhav-Jain,25,3541,cpp,"class Solution {
public:
    bool reportSpam(vector<string>& message, vector<string>& bannedWords) 
    {
        map<string, bool> amap;
        map<string, int> freq;
        for (auto &i : bannedWords)
        {
            amap[i] = true;
        }
        int cnt = 0;
        for (auto &i : message)
        {
           cnt += amap[i];
        }
        return (cnt >= 2);
        return false;
    }
};",1397962939
Sambhav Jain,Sambhav-Jain,25,3572,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992682
Sambhav Jain,Sambhav-Jain,25,3573,cpp,"class Solution {
public:
    long long validSubstringCount(string word1, string word2) 
    {
        long long ans = 0;
        vector<int> freq(26, 0);
        for (auto &i : word2)
        {
            freq[i - 'a']++;
        }
        for (int left = 0, right = 0; left < word1.size(); left++)
        {
            while (right < word1.size() && *max_element(freq.begin(), freq.end()) > 0)
            {
                freq[word1[right] - 'a']--;
                right++;
            }
            if (*max_element(freq.begin(), freq.end()) <= 0)
            {
                ans += word1.size() - right + 1;
            }
            freq[word1[left] - 'a']++;
        }
        return ans;
    }
};",1397992282
